# call、apply、bind

## call

**思路**

1. 根据call的规则设置上下文对象,也就是`this`的指向。
2. 通过设置`context`的属性,将函数的this指向[隐式绑定](https://juejin.cn/post/6844903630592540686#heading-4)到context上
3. 通过隐式绑定执行函数并传递参数。
4. 删除临时属性，返回函数执行结果

**代码实现**

```js
Function.prototype.myCall = function (context, ...arr) {
    if (context === null || context === undefined) {
       // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)
        context = window 
    } else {
        context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象
    }
    const specialPrototype = Symbol('特殊属性Symbol') // 用于临时储存函数
    context[specialPrototype] = this; // 函数的this指向隐式绑定到context上
    let result = context[specialPrototype](...arr); // 通过隐式绑定执行函数并传递参数
    delete context[specialPrototype]; // 删除上下文对象的属性
    return result; // 返回函数执行结果
};
```

## apply

**思路**

1. 传递给函数的参数处理，不太一样，其他部分跟`call`一样。
2. `apply`接受第二个参数为类数组对象, 这里用了JavaScript权威指南中判断是否为类数组对象的方法。

**代码实现**

```js
Function.prototype.myApply = function (context) {
    if (context === null || context === undefined) {
        context = window // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)
    } else {
        context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象
    }
    // JavaScript权威指南判断是否为类数组对象
    function isArrayLike(o) {
        if (o &&                                    // o不是null、undefined等
            typeof o === 'object' &&                // o是对象
            isFinite(o.length) &&                   // o.length是有限数值
            o.length >= 0 &&                        // o.length为非负值
            o.length === Math.floor(o.length) &&    // o.length是整数
            o.length < 4294967296)                  // o.length < 2^32
            return true
        else
            return false
    }
    const specialPrototype = Symbol('特殊属性Symbol') // 用于临时储存函数
    context[specialPrototype] = this; // 隐式绑定this指向到context上
    let args = arguments[1]; // 获取参数数组
    let result
    // 处理传进来的第二个参数
    if (args) {
        // 是否传递第二个参数
        if (!Array.isArray(args) && !isArrayLike(args)) {
            throw new TypeError('myApply 第二个参数不为数组并且不为类数组对象抛出错误');
        } else {
            args = Array.from(args) // 转为数组
            result = context[specialPrototype](...args); // 执行函数并展开数组，传递函数参数
        }
    } else {
        result = context[specialPrototype](); // 执行函数 
    }
    delete context[specialPrototype]; // 删除上下文对象的属性
    return result; // 返回函数执行结果
};
```

## bind

**思路**

1. 拷贝源函数:
   - 通过变量储存源函数
   - 使用`Object.create`复制源函数的prototype给fToBind
2. 返回拷贝的函数
3. 调用拷贝的函数：
   - new调用判断：通过`instanceof`判断函数是否通过`new`调用，来决定绑定的`context`
   - 绑定this+传递参数
   - 返回源函数的执行结果

**代码实现**

```js
Function.prototype.myBind = function (objThis, ...params) {
    const thisFn = this; // 存储源函数以及上方的params(函数参数)
    // 对返回的函数 secondParams 二次传参
    let fToBind = function (...secondParams) {
        const isNew = this instanceof fToBind // this是否是fToBind的实例 也就是返回的fToBind是否通过new调用
        const context = isNew ? this : Object(objThis) // new调用就绑定到this上,否则就绑定到传入的objThis上
        return thisFn.call(context, ...params, ...secondParams); // 用call调用源函数绑定this的指向并传递参数,返回执行结果
    };
    if (thisFn.prototype) {
        // 复制源函数的prototype给fToBind 一些情况下函数没有prototype，比如箭头函数
        fToBind.prototype = Object.create(thisFn.prototype);
    }
    return fToBind; // 返回拷贝的函数
};
```



# new

**思想**

1. 首先函数接受不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用
2. 然后内部创建一个空对象 `obj`
3. 因为 `obj` 对象需要访问到构造函数原型链上的属性，所以我们通过 `setPrototypeOf` 将两者联系起来。这段代码等同于 `obj.__proto__ = Con.prototype`
4. 将 `obj` 绑定到构造函数上，并且传入剩余的参数
5. 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 `obj`，这样就实现了忽略构造函数返回的原始值

**代码实现**

```js
function create(Con, ...args) {
  let obj = {}
  Object.setPrototypeOf(obj, Con.prototype)
  let result = Con.apply(obj, args)
  return result instanceof Object ? result : obj
}

```

# instanceof 

instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上。

```js
function instanceOf(left, right) {
    let proto = left.__proto__
    while (true) {
        if (proto === null) return false
        if (proto === right.prototype) {
            return true
        }
        proto = proto.__proto__
    }
}
```

上面的 left.**proto** 这种写法可以换成 Object.getPrototypeOf(left)。




# 柯里化

**思想**

柯里化又称“部分求值”，一个curring函数首先会接受一些参数，接受了这些参数后，该函数不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数的闭包环境中存储起来，待到函数真正需要被求值的时候，之前传入的参数都会被一次性用于求值。

**代码实现**

```js
const curry = function(fn) {
  return function inner() {
    // 浅拷贝入参
    const args = Array.prototype.slice.call(arguments);
    // 如果下一个参数的长度大于了函数的行参个数，则跳出递归
    if (arguments.length >= fn.length) {
      return fn.apply(undefined, args);
    } else {
      // 否则继续处理后续参数，返回curring函数
      return function() {
        // 获取合并上一次和下一次的入参
        const allArgs = args.concat(Array.prototype.slice.call(arguments));
        return inner.apply(undefined, allArgs);
      };
    }
  };
}

function sum(a, b, c) {
    return a + b + c;
}

const currySum = curry(sum);
console.log(currySum(1)(2)(3)); //6
```

**ES6实现**

**思想**

1. 调用curry函数，获取函数fn的参数。
2. 定义一个新的函数judge，接收参数为`...args。`
3. 判断新函数接受的参数长度是否大于等于fn剩余参数需要接收的长度
4. 满足要求，则执行fn函数，并传入新函数的参数
5. 否则，返回一个新的匿名函数，这个函数把所有传入参数`...args`保存在`arg`数组中，而这个匿名函数被执行后，就把以前收到的参数数组和当前的参数数组合并后，放到前面说的逻辑中，在judge函数里判断，重复第3步。



```js
const curry = fn =>
  judge = (...args) =>
    args.length >= fn.length 
      ? fn(...args) 
      : arg => judge(...args, arg);

```

# 继承

## 原型继承

- 核心思想：**将父类的实例作为子类的原型。**

- 优点：方法复用

  ​	由于方法定义在父类的原型上，复用了父类构造函数原型上的方法。

- 缺点：

  ​	创建的子类实例**不能传参**。

  ​	子类实例**共享了**父类构造函数的**引用类型属性**（如：arr）

- 但是如果**不是引用类型**就不存在这种问题，每创建一个实例，都会为每个实例的**基本数据类型**重新分配一个内存空间，相互之间不干扰。

```js
function Animal() {
    this.colors = ['black', 'white']
}
Animal.prototype.getColor = function() {
    return this.colors
}
function Dog() {}
Dog.prototype =  new Animal()// 这里是关键，创建父类的实例，并将该实例赋值给子类的原型

let dog1 = new Dog()
dog1.colors.push('brown')
let dog2 = new Dog()
console.log(dog2.colors)  // ['black', 'white', 'brown']
```

## 借用构造函数继承

- 核心思想：使用父类的构造函数来增强子类**实例**，等同于复制父类的实例给子类（不使用原型）

- 优点：

  ​	借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。

- 缺点：


​			只能继承父类的**实例**属性和方法，不能继承**原型**属性/方法

​			无法实现复用，每个子类都有父类实例函数的副本，影响性能

```js
function Animal(name) {
    this.name = name
    this.getName = function() {
        return this.name
    }
}
function Dog(name) {
    Animal.call(this, name)//核心代码是`SuperType.call(this)`，创建子类实例时调用`SuperType`构造函数，于是`SubType`的每个实例都会将SuperType中的属性复制一份
}
```

## 组合继承

优点：

组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。

缺点：

- 第一次调用`SuperType()`：给`SubType.prototype`写入两个属性name，color。
- 第二次调用`SuperType()`：给`dog1`写入两个属性name，color。

实例对象`instance1`上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，**组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法**。

```js
function Animal(name) {
    this.name = name
    this.colors = ['black', 'white']
}
Animal.prototype.getName = function() {
    return this.name
}
function Dog(name, age) {
    // 第二次调用SuperType()
    Animal.call(this, name)
    this.age = age
}
// 第一次调用SuperType()
Dog.prototype =  new Animal()
Dog.prototype.constructor = Dog// 重写Dog.prototype的constructor属性，指向自己的构造函数Dog

let dog1 = new Dog('奶昔', 2)
dog1.colors.push('brown')
let dog2 = new Dog('哈赤', 1)
console.log(dog2) 
// { name: "哈赤", colors: ["black", "white"], age: 1 }

```

## 寄生式组合继承

解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建父类原型的副本并且增强副本。

这个例子的高效率体现在它只调用了一次`SuperType` 构造函数，并且因此避免了在`SubType.prototype` 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用`instanceof` 和`isPrototypeOf()`

**这是最成熟的方法，也是现在库实现的方法**

```js
function inheritPrototype(subType, superType){
  var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本
  prototype.constructor = subType;                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性
  subType.prototype = prototype;                      // 指定对象，将新创建的对象赋值给子类的原型
}

// 父类初始化实例属性和原型属性
function SuperType(name){
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
  alert(this.name);
};

// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）
function SubType(name, age){
  SuperType.call(this, name);
  this.age = age;
}

// 将父类原型指向子类
inheritPrototype(SubType, SuperType);

// 新增子类原型属性
SubType.prototype.sayAge = function(){
  alert(this.age);
}

var instance1 = new SubType("xyc", 23);
var instance2 = new SubType("lxy", 23);

instance1.colors.push("2"); // ["red", "blue", "green", "2"]
instance1.colors.push("3"); // ["red", "blue", "green", "3"]
```

## ES6类和extends

- 核心思想：

  ​	extends： 内部相当于设置了 Son.prototype = Object.create(Father.prototype);

  ​	super(): 内部相当于调用了 Father.call(this)

- 小结：

  ​	子类只要继承父类，可以不写 constructor ，一旦写了，则在 constructor 中的第一句话必须是 super 。

  ​	把父类当做普通方法执行，给方法传递参数，让方法中的 this 是子类的实例。

ES6 的 extend 继承其实就是寄生组合式继承的语法糖。它参考了`java`语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。`Class`类可以通过`extends`实现继承。它和ES5构造函数的不同点

- `ES6`的`class`类必须用`new`命令操作，而`ES5`的构造函数不用`new`也可以执行。
- `ES6`的`class`类不存在变量提升，必须先定义`class`之后才能实例化，不像`ES5`中可以将构造函数写在实例化之后。
- `ES5` 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面。`ES6` 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。

```js
class Animal {
    constructor(name) {
        this.name = name
    } 
    getName() {
        return this.name
    }
}
class Dog extends Animal {
    constructor(name, age) {
        super(name)
        this.age = age
    }
}
```



# 浅拷贝、深拷贝

## 浅拷贝

```js
function shallowCopy(obj) {
    if (typeof obj !== 'object') return
    
    let newObj = obj instanceof Array ? [] : {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = obj[key]
        }
    }
    return newObj
}
```

## 深拷贝

- 支持对象、数组、日期、正则的拷贝。
- 处理原始类型（原始类型直接返回，只有引用类型才有深拷贝这个概念）。
- 处理 Symbol 作为键名的情况。
- 处理函数（函数直接返回，拷贝函数没有意义，两个对象使用内存中同一个地址的函数，问题不大）。
- 处理 DOM 元素（DOM 元素直接返回，拷贝 DOM 元素没有意义，都是指向页面中同一个）。
- 额外开辟一个储存空间 WeakMap，解决循环引用递归爆栈问题（引入 WeakMap 的另一个意义，配合垃圾回收机制，防止内存泄漏）。

```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj); // 当需要拷贝当前对象时，先去存储空间中找，如果有的话直接返回
  let cloneObj = new obj.constructor();// 创建一个新的克隆对象或克隆数组
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);// 如果存储空间中没有就存进 hash 里
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}

let obj = { name: 1, address: { x: 100 } };
obj.o = obj; // 对象存在循环引用的情况
let d = deepClone(obj);
obj.address.x = 200;
console.log(d);
```

# Promise

### new Promise

实现 Promise 需要完全读懂 [Promise A+ 规范](https://link.juejin.cn?target=https%3A%2F%2Fpromisesaplus.com%2F)，不过从总体的实现上看，有如下几个点需要考虑到：

- then 需要支持链式调用，所以得返回一个新的 Promise；
- 处理异步问题，所以得先用 onResolvedCallbacks 和 onRejectedCallbacks 分别把成功和失败的回调存起来；
- 为了让链式调用正常进行下去，需要判断 onFulfilled 和 onRejected 的类型；
- onFulfilled 和 onRejected 需要被异步调用，这里用 setTimeout 模拟异步；
- 处理 Promise 的 resolve；

```js
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class Promise {
    constructor(executor) {
        this.status = PENDING;
        this.value = undefined;
        this.reason = undefined;
        this.onResolvedCallbacks = []; // 存放成功的回调
        this.onRejectedCallbacks = []; // 存放失败的回调
        
        let resolve = (value) = > {
            if (this.status === PENDING) {
                this.status = FULFILLED;
                this.value = value;
                this.onResolvedCallbacks.forEach((fn) = > fn()); // 依次将对应的函数执行
            }
        };
        
        let reject = (reason) = > {
            if (this.status === PENDING) {
                this.status = REJECTED;
                this.reason = reason;
                this.onRejectedCallbacks.forEach((fn) = > fn()); // 依次将对应的函数执行
            }
        };
        
        try {
            executor(resolve, reject);
        } catch (error) {
            reject(error);
        }
    }
    
    then(onFulfilled, onRejected) {
        // 解决 onFufilled，onRejected 没有传值的问题
        onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (v) = > v;
        // 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获
        onRejected = typeof onRejected === "function" ? onRejected : (err) = > {
            throw err;
        };
        // 每次调用 then 都返回一个新的 promise
        let promise2 = new Promise((resolve, reject) = > {
            if (this.status === FULFILLED) {
                //Promise/A+ 2.2.4 --- setTimeout
                setTimeout(() = > {
                    try {
                        let x = onFulfilled(this.value);
                        // x可能是一个proimise
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (e) {
                        reject(e);
                    }
                }, 0);
            }
        
            if (this.status === REJECTED) {
                //Promise/A+ 2.2.3
                setTimeout(() = > {
                    try {
                        let x = onRejected(this.reason);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (e) {
                        reject(e);
                    }
                }, 0);
            }
            
            if (this.status === PENDING) {
                this.onResolvedCallbacks.push(() = > {
                    setTimeout(() = > {
                        try {
                            let x = onFulfilled(this.value);
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (e) {
                            reject(e);
                        }
                    }, 0);
                });
            
                this.onRejectedCallbacks.push(() = > {
                    setTimeout(() = > {
                        try {
                            let x = onRejected(this.reason);
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (e) {
                            reject(e);
                        }
                    }, 0);
                });
            }
        });
        
        return promise2;
    }
}
const resolvePromise = (promise2, x, resolve, reject) = > {
    // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1
    if (promise2 === x) {
        return reject(
            new TypeError("Chaining cycle detected for promise #<Promise>"));
    }
    // Promise/A+ 2.3.3.3.3 只能调用一次
    let called;
    // 后续的条件要严格判断 保证代码能和别的库一起使用
    if ((typeof x === "object" && x != null) || typeof x === "function") {
        try {
            // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
            let then = x.then;
            if (typeof then === "function") {
            // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
                then.call(
                    x, (y) = > {
                        // 根据 promise 的状态决定是成功还是失败
                        if (called) return;
                        called = true;
                        // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
                        resolvePromise(promise2, y, resolve, reject);
                    }, (r) = > {
                        // 只要失败就失败 Promise/A+ 2.3.3.3.2
                        if (called) return;
                        called = true;
                        reject(r);
                    });
            } else {
                // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
                resolve(x);
            }
        } catch (e) {
            // Promise/A+ 2.3.3.2
            if (called) return;
            called = true;
            reject(e);
        }
    } else {
        // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4
        resolve(x);
    }
};
```



### Promise.resolve

Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。

```js
Promise.resolve = function(value) {
    // 如果是 Promsie，则直接输出它
    if(value instanceof Promise){
        return value
    }
    return new Promise(resolve => resolve(value))
}
```

参考：[深入理解 Promise](https://link.juejin.cn?target=https%3A%2F%2Fbubuzou.com%2F2020%2F10%2F22%2Fpromise%2F)

### Promise.reject

和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。

```js
Promise.reject = function(reason) {
    return new Promise((resolve, reject) => reject(reason))
}
```

### **Promise.prototype.catch**

Promise.prototype.catch 用来捕获 promise 的异常，**就相当于一个没有成功的 then**。

```js
Promise.prototype.catch = function(errCallback){
  return this.then(null,errCallback)
}
```

### **Promise.prototype.finally**

finally 表示不是最终的意思，而是无论如何都会执行的意思。 如果返回一个 promise 会等待这个 promise 也执行完毕。如果返回的是成功的 promise，会采用上一次的结果；如果返回的是失败的 promise，会用这个失败的结果，传到 catch 中。

```js
Promise.prototype.finally = function(callback) {
  return this.then((value)=>{
    return Promise.resolve(callback()).then(()=>value)
  },(reason)=>{
    return Promise.resolve(callback()).then(()=>{throw reason})
  })  
}
```

### Promise.all

Promise.all 的规则是这样的：

- 传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；
- 只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；
- 只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；

```js
Promise.all = function(promiseArr) {
    let index = 0, result = []
    return new Promise((resolve, reject) => {
        promiseArr.forEach((p, i) => {
            Promise.resolve(p).then(val => {
                index++
                result[i] = val
                if (index === promiseArr.length) {
                    resolve(result)
                }
            }, err => {
                reject(err)
            })
        })
    })
}
```

### Promise.race

Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。

```js
Promise.race = function(promiseArr) {
    return new Promise((resolve, reject) => {
        promiseArr.forEach(p => {
            Promise.resolve(p).then(val => {
                resolve(val)
            }, err => {
                rejecte(err)
            })
        })
    })
}
```

### Promise.allSettled

Promise.allSettled 的规则是这样：

- 所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象；
- 如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例；

```js
Promise.allSettled = function(promiseArr) {
    let result = []
        
    return new Promise((resolve, reject) => {
        promiseArr.forEach((p, i) => {
            Promise.resolve(p).then(val => {
                result.push({
                    status: 'fulfilled',
                    value: val
                })
                if (result.length === promiseArr.length) {
                    resolve(result) 
                }
            }, err => {
                result.push({
                    status: 'rejected',
                    reason: err
                })
                if (result.length === promiseArr.length) {
                    resolve(result) 
                }
            })
        })  
    })   
}
```

### Promise.any

Promise.any 的规则是这样：

- 空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；
- 只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；
- 其他情况都会返回一个 pending 的新实例；

```js
Promise.any = function(promiseArr) {
    let index = 0
    return new Promise((resolve, reject) => {
        if (promiseArr.length === 0) return 
        promiseArr.forEach((p, i) => {
            Promise.resolve(p).then(val => {
                resolve(val)
                
            }, err => {
                index++
                if (index === promiseArr.length) {
                  reject(new AggregateError('All promises were rejected'))
                }
            })
        })
    })
}
```

### 串行执行Promise

```js
function delay(time) {
    return new Promise((resolve, reject) => {
        console.log(`wait ${time}s`)
        setTimeout(() => {
            console.log('execute')
            resolve()
        }, time * 1000)
    })
}

const arr = [1, 2, 3]

// reduce
arr.reduce((s, v) => {
    return s.then(() => delay(v))
}, Promise.resolve())

// reduce的普通写法
let p = Promise.resolve()
for (let v of arr) {
    p.then(() => delay(v))
}

// async & await
async function serial() {
    for (let v of arr) {
        await delay(v)
    }
}
serial()

// 生成器
function* gen() {
    for (let v of arr) {
        yield delay(v)
    }
}
function run(gen) {
    const iter = gen()
    function next() {
        const result = iter.next()
        if (result.done) return result.value
        result.value.then(function () {
            next()
        })
    }
    next()
}
run(gen)

// for wait of
function asyncIterable(arr) {
    return {
        [Symbol.asyncIterator]() {
            return {
                i: 0,
                next() {
                    if (this.i < arr.length) {
                        return delay(arr[this.i]).then(() => ({ value: this.i++, done: false }));
                    }
                    return Promise.resolve({ done: true });
                }
            }
        }
    }
}

(async function () {
    for await (i of asyncIterable(arr)) { 
    }
})()

// 生成器与 for await of 结合
async function * asyncGenerator() {
    for (let v of arr) {
        yield delay(v)
    }
}

(async () => {
    for await (const item of asyncGenerator()) {
    }
})()
```



# 防抖

> 触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。

简单版：函数内部支持使用 this 和 event 对象；

```js
function debounce(func, wait) {
    var timeout;// 创建一个标记用来存放定时器的返回值
    return function () {
        var context = this;
        var args = arguments;
        clearTimeout(timeout)// 每当用户输入的时候把前一个 setTimeout clear 掉
        timeout = setTimeout(function(){// 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数
            func.apply(context, args)
        }, wait);
    }
}
```

使用：

```js
var node = document.getElementById('layout')
function getUserAction(e) {
    console.log(this, e)  // 分别打印：node 这个节点 和 MouseEvent
    node.innerHTML = count++;
};
node.onmousemove = debounce(getUserAction, 1000)
```

最终版：除了支持 this 和 event 外，还支持以下功能：

- 支持立即执行；
- 函数可能有返回值；
- 支持取消功能；

```js
function debounce(func, wait, immediate) {
    var timeout, result;
    
    var debounced = function () {
        var context = this;
        var args = arguments;
        
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            // 如果已经执行过，不再执行
            var callNow = !timeout;
            timeout = setTimeout(function(){
                timeout = null;
            }, wait)
            if (callNow) result = func.apply(context, args)
        } else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
        return result;
    };

    debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = null;
    };

    return debounced;
}
```

使用：

```js
var setUseAction = debounce(getUserAction, 10000, true);
// 使用防抖
node.onmousemove = setUseAction

// 取消防抖
setUseAction.cancel()
```

# 节流

> 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。

```js
function throttle(func, wait) {
    var context, args;
    var previous = 0;

    return function() {
        var now = +new Date();
        context = this;
        args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}

let input1 = document.getElementById('input1')
let sayHi = function () {
    console.log('hi')
}
input1.addEventListener('keydown', throttle(sayHi, 2000));
```

最终版：支持取消节流；另外通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。 注意设置的时候不能同时将 leading 或 trailing 设置为 false。

```js
function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
        previous = options.leading === false ? 0 : new Date().getTime();
        timeout = null;
        func.apply(context, args);
        if (!timeout) context = args = null;
    };

    var throttled = function() {
        var now = new Date().getTime();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
    };
    
    throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = null;
    }
    return throttled;
}
```

节流的使用就不拿代码举例了，参考防抖的写就行

# 数组去重

ES5 实现：

```js
function unique(arr) {
    var res = arr.filter(function(item, index, array) {
        return array.indexOf(item) === index
    })
    return res
}
```

ES6 实现：

```js
var unique = arr => [...new Set(arr)]
```

# 数组扁平

数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层：

```js
[1, [2, [3]]].flat(2)  // [1, 2, 3]
```

现在就是要实现 flat 这种效果。

ES5 实现：递归。

```js
function flatten(arr) {
    var result = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        if (Array.isArray(arr[i])) {
            result = result.concat(flatten(arr[i]))
        } else {
            result.push(arr[i])
        }
    }
    return result;
}
```

ES6 实现：

```js
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}
```

# forEach() map() reduce() filter() every() some() find() findIndex()

## forEach

```js
Array.prototype.forEach2 = function(callback, thisArg) {
    if (this == null) {
        throw new TypeError('this is null or not defined')
    }
    if (typeof callback !== "function") {
        throw new TypeError(callback + ' is not a function')
    }
    const O = Object(this)  // this 就是当前的数组
    const len = O.length >>> 0  // 后面有解释
    let k = 0
    while (k < len) {
        if (k in O) {
            callback.call(thisArg, O[k], k, O);
        }
        k++;
    }
}
```

参考：[forEach#polyfill](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2FforEach%23polyfill)

O.length >>> 0 是什么操作？就是无符号右移 0 位，那有什么意义嘛？就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。感兴趣可以阅读 [something >>> 0是什么意思?](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F100790268)。

## map

基于 forEach 的实现能够很容易写出 map 的实现：

```diff
- Array.prototype.forEach2 = function(callback, thisArg) {
+ Array.prototype.map2 = function(callback, thisArg) {
    if (this == null) {
        throw new TypeError('this is null or not defined')
    }
    if (typeof callback !== "function") {
        throw new TypeError(callback + ' is not a function')
    }
    const O = Object(this)
    const len = O.length >>> 0
-   let k = 0
+   let k = 0, res = []
    while (k < len) {
        if (k in O) {
-           callback.call(thisArg, O[k], k, O);
+           res[k] = callback.call(thisArg, O[k], k, O);
        }
        k++;
    }
+   return res
}
```

## filter

同样，基于 forEach 的实现能够很容易写出 filter 的实现：

```diff
- Array.prototype.forEach2 = function(callback, thisArg) {
+ Array.prototype.filter2 = function(callback, thisArg) {
    if (this == null) {
        throw new TypeError('this is null or not defined')
    }
    if (typeof callback !== "function") {
        throw new TypeError(callback + ' is not a function')
    }
    const O = Object(this)
    const len = O.length >>> 0
-   let k = 0
+   let k = 0, res = []
    while (k < len) {
        if (k in O) {
-           callback.call(thisArg, O[k], k, O);
+           if (callback.call(thisArg, O[k], k, O)) {
+               res.push(O[k])                
+           }
        }
        k++;
    }
+   return res
}
```

## some

同样，基于 forEach 的实现能够很容易写出 some 的实现：

```diff
- Array.prototype.forEach2 = function(callback, thisArg) {
+ Array.prototype.some2 = function(callback, thisArg) {
    if (this == null) {
        throw new TypeError('this is null or not defined')
    }
    if (typeof callback !== "function") {
        throw new TypeError(callback + ' is not a function')
    }
    const O = Object(this)
    const len = O.length >>> 0
    let k = 0
    while (k < len) {
        if (k in O) {
-           callback.call(thisArg, O[k], k, O);
+           if (callback.call(thisArg, O[k], k, O)) {
+               return true
+           }
        }
        k++;
    }
+   return false
}
```

## reduce

```js
Array.prototype.reduce2 = function(callback, initialValue) {
    if (this == null) {
        throw new TypeError('this is null or not defined')
    }
    if (typeof callback !== "function") {
        throw new TypeError(callback + ' is not a function')
    }
    const O = Object(this)
    const len = O.length >>> 0
    let k = 0, acc
    
    if (arguments.length > 1) {
        acc = initialValue
    } else {
        // 没传入初始值的时候，取数组中第一个非 empty 的值为初始值
        while (k < len && !(k in O)) {
            k++
        }
        if (k > len) {
            throw new TypeError( 'Reduce of empty array with no initial value' );
        }
        acc = O[k++]
    }
    while (k < len) {
        if (k in O) {
            acc = callback(acc, O[k], k, O)
        }
        k++
    }
    return acc
}
```





# 事件总线（发布订阅模式）

```js
class EventEmitter {
    // 定义所有事件列表,格式如下：
    // {
    //   key: Array,
    //   key: Array,
    // } 
    // Array存储的是注册的回调函数
    constructor() {
        this.cache = {}// 用于存储所有订阅事件
    }
    // 订阅事件,类似监听事件$on('key',()=>{})
    on (name, fn) {
        if (this.cache[name]) {
            this.cache[name].push(fn)
        } else {
            this.cache[name] = [fn]
        }
    }
    // 取消订阅函数，类似于$off('key1', id) 
    off(name, fn) {
        let tasks = this.cache[name]
        if (tasks) {
            const index = tasks.findIndex(f => f === fn || f.callback === fn)
            if (index >= 0) {
                tasks.splice(index, 1)
            }
        }
    }
    // 发布事件,类似于触发事件$emit('key')
    emit(name, once = false, ...args) {
        if (this.cache[name]) {
            // 创建副本，如果回调函数内继续注册相同事件，会造成死循环
            let tasks = this.cache[name].slice()
            for (let fn of tasks) {
                fn(...args)
            }
            if (once) {
                delete this.cache[name]
            }
        }
    }
}

// 测试
let eventBus = new EventEmitter()
let fn1 = function(name, age) {
	console.log(`${name} ${age}`)
}
let fn2 = function(name, age) {
	console.log(`hello, ${name} ${age}`)
}
eventBus.on('aaa', fn1)
eventBus.on('aaa', fn2)
eventBus.emit('aaa', false, '布兰', 12)
// '布兰 12'
// 'hello, 布兰 12'
```

# 解析 URL 参数为对象 

```js
function parseParam(url) {
    const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来
    const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组中
    let paramsObj = {};
    // 将 params 存到对象中
    paramsArr.forEach(param => {
        if (/=/.test(param)) { // 处理有 value 的参数
            let [key, val] = param.split('='); // 分割 key 和 value
            val = decodeURIComponent(val); // 解码
            val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字
    
            if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值
                paramsObj[key] = [].concat(paramsObj[key], val);
            } else { // 如果对象没有这个 key，创建 key 并设置值
                paramsObj[key] = val;
            }
        } else { // 处理没有 value 的参数
            paramsObj[param] = true;
        }
    })
    
    return paramsObj;
}
```

# 模板字符串

```js
function render(template, data) {
    const reg = /\{\{(\w+)\}\}/; // 模板字符串正则
    if (reg.test(template)) { // 判断模板里是否有模板字符串
        const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段
        template = template.replace(reg, data[name]); // 将第一个模板字符串渲染
        return render(template, data); // 递归的渲染并返回渲染后的结构
    }
    return template; // 如果模板没有模板字符串直接返回
}
```

测试：

```js
let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';
let person = {
    name: '布兰',
    age: 12
}
render(template, person); // 我是布兰，年龄12，性别undefined
```

# JSONP

JSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求；

```js
const jsonp = ({ url, params, callbackName }) => {
    const generateUrl = () => {
        let dataSrc = ''
        for (let key in params) {
            if (params.hasOwnProperty(key)) {
                dataSrc += `${key}=${params[key]}&`
            }
        }
        dataSrc += `callback=${callbackName}`
        return `${url}?${dataSrc}`
    }
    return new Promise((resolve, reject) => {
        const scriptEle = document.createElement('script')
        scriptEle.src = generateUrl()
        document.body.appendChild(scriptEle)
        window[callbackName] = data => {
            resolve(data)
            document.removeChild(scriptEle)
        }
    })
}
```



# 实现 Object.create

Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。

```js
Object.create2 = function(proto, propertyObject = undefined) {
    if (typeof proto !== 'object' && typeof proto !== 'function') {
        throw new TypeError('Object prototype may only be an Object or null.')
    if (propertyObject == null) {
        new TypeError('Cannot convert undefined or null to object')
    }
    function F() {}
    F.prototype = proto
    const obj = new F()
    if (propertyObject != undefined) {
        Object.defineProperties(obj, propertyObject)
    }
    if (proto === null) {
        // 创建一个没有原型对象的对象，Object.create(null)
        obj.__proto__ = null
    }
    return obj
}
```

# 实现 Object.assign

```js
Object.assign2 = function(target, ...source) {
    if (target == null) {
        throw new TypeError('Cannot convert undefined or null to object')
    }
    let ret = Object(target) 
    source.forEach(function(obj) {
        if (obj != null) {
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    ret[key] = obj[key]
                }
            }
        }
    })
    return ret
}
```

# 实现 Object.entries

```js
const entries = (inArg)=>{
  if(Array.isArray(inArg)){
    return inArg.map((x,index)=>[`${index}`,x])
  }
  if(Object.prototype.toString.call(inArg) === `[object Object]`){
   return Object.keys(inArg).map(y=>[y,inArg[y]])
  }
  if(typeof inArg === 'number')return []
  throw 'Cannot convert argument to object'
} 

// test
console.log(entries(1)) 
// []

console.log(entries([1,2,3])) 
// [ [ '0', 1 ], [ '1', 2 ], [ '2', 3 ] ]

console.log(entries({age:12,name:'ysss'})) 
// [ [ 'age', 12 ], [ 'name', 'ysss' ] ]

if(!Object.entries)Object.entries = entries;
```



# 实现 JSON.stringify

JSON.stringify([, replacer [, space]) 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 replacer 和第三个参数 space，如果对这两个参数的作用还不了解，建议阅读 [MDN](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FJSON%2Fstringify) 文档。

1. 基本数据类型：
   - undefined 转换之后仍是 undefined(类型也是 undefined)
   - boolean 值转换之后是字符串 "false"/"true"
   - number 类型(除了 NaN 和 Infinity)转换之后是字符串类型的数值
   - symbol 转换之后是 undefined
   - null 转换之后是字符串 "null"
   - string 转换之后仍是string
   - NaN 和 Infinity 转换之后是字符串 "null"
2. 函数类型：转换之后是 undefined
3. 如果是对象类型(非函数)
   - 如果是一个数组：如果属性值中出现了 undefined、任意的函数以及 symbol，转换成字符串 "null" ；
   - 如果是 RegExp 对象：返回 {} (类型是 string)；
   - 如果是 Date 对象，返回 Date 的 toJSON 字符串值；
   - 如果是普通对象；
     - 如果有 toJSON() 方法，那么序列化 toJSON() 的返回值。
     - 如果属性值中出现了 undefined、任意的函数以及 symbol 值，忽略。
     - 所有以 symbol 为属性键的属性都会被完全忽略掉。
4. 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。

```js
function jsonStringify(data) {
    let dataType = typeof data;
    
    if (dataType !== 'object') {
        let result = data;
        //data 可能是 string/number/null/undefined/boolean
        if (Number.isNaN(data) || data === Infinity) {
            //NaN 和 Infinity 序列化返回 "null"
            result = "null";
        } else if (dataType === 'function' || dataType === 'undefined' || dataType === 'symbol') {
            //function 、undefined 、symbol 序列化返回 undefined
            return undefined;
        } else if (dataType === 'string') {
            result = '"' + data + '"';
        }
        //boolean 返回 String()
        return String(result);
    } else if (dataType === 'object') {
        if (data === null) {
            return "null"
        } else if (data.toJSON && typeof data.toJSON === 'function') {
            return jsonStringify(data.toJSON());
        } else if (data instanceof Array) {
            let result = [];
            //如果是数组
            //toJSON 方法可以存在于原型链中
            data.forEach((item, index) => {
                if (typeof item === 'undefined' || typeof item === 'function' || typeof item === 'symbol') {
                    result[index] = "null";
                } else {
                    result[index] = jsonStringify(item);
                }
            });
            result = "[" + result + "]";
            return result.replace(/'/g, '"');
            
        } else {
            //普通对象
            /**
             * 循环引用抛错(暂未检测，循环引用时，堆栈溢出)
             * symbol key 忽略
             * undefined、函数、symbol 为属性值，被忽略
             */
            let result = [];
            Object.keys(data).forEach((item, index) => {
                if (typeof item !== 'symbol') {
                    //key 如果是symbol对象，忽略
                    if (data[item] !== undefined && typeof data[item] !== 'function'
                        && typeof data[item] !== 'symbol') {
                        //键值如果是 undefined、函数、symbol 为属性值，忽略
                        result.push('"' + item + '"' + ":" + jsonStringify(data[item]));
                    }
                }
            });
            return ("{" + result + "}").replace(/'/g, '"');
        }
    }
}
```

参考：[实现 JSON.stringify](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FYvetteLau%2FStep-By-Step%2Fissues%2F39%23issuecomment-508327280)

# 实现 JSON.parse

介绍 2 种方法实现：

- eval 实现；
- new Function 实现；

## eval 实现

第一种方式最简单，也最直观，就是直接调用 eval，代码如下：

```js
var json = '{"a":"1", "b":2}';
var obj = eval("(" + json + ")");  // obj 就是 json 反序列化之后得到的对象
```

但是直接调用 eval 会存在安全问题，如果数据中可能不是 json 数据，而是可执行的 JavaScript 代码，那很可能会造成 XSS 攻击。因此，在调用 eval 之前，需要对数据进行校验。

```js
var rx_one = /^[\],:{}\s]*$/;
var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rx_four = /(?:^|:|,)(?:\s*\[)+/g;

if (
    rx_one.test(
        json.replace(rx_two, "@")
            .replace(rx_three, "]")
            .replace(rx_four, "")
    )
) {
    var obj = eval("(" +json + ")");
}
```

参考：[JSON.parse 三种实现方式](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyoungwind%2Fblog%2Fissues%2F115%23issue-300869613)

## new Function 实现

Function 与 eval 有相同的字符串参数特性。

```js
var json = '{"name":"小姐姐", "age":20}';
var obj = (new Function('return ' + json))();
```





# EventBus

基于发布订阅模式实现的EventBus

```js
   class EventBus{
        constructor(){
            this.event=Object.create(null);
        };
        //注册事件
        on(name,fn){
            if(!this.event[name]){
                //一个事件可能有多个监听者
                this.event[name]=[];
            };
            this.event[name].push(fn);
        };
        //触发事件
        emit(name,...args){
            //给回调函数传参
            this.event[name]&&this.event[name].forEach(fn => {
                fn(...args)
            });
        };
        //只被触发一次的事件
        once(name,fn){
            //在这里同时完成了对该事件的注册、对该事件的触发，并在最后取消该事件。
            const cb=(...args)=>{
                //触发
                fn(...args);
                //取消
                this.off(name,fn);
            };
            //监听
            this.on(name,cb);
        };
        //取消事件
        off(name,offcb){
            if(this.event[name]){
                let index=this.event[name].findIndex((fn)=>{
                    return offcb===fn;
                })
                this.event[name].splice(index,1);
                if(!this.event[name].length){
                    delete this.event[name];
                }
            }
        }
    }
```

# Vue.$set

set 方法接收三个参数：

- target：数组或普通对象
- key：表示数组下标或对象的 key 名
- val：表示要替换的新值

这里主要做的是：

- 先判断如果是数组，并且下标合法，就直接使用重写过的 splice 替换
- 如果是对象，并且 key 存在于 target 里，就替换值
- 如果没有 `__ob__`，说明不是一个响应式对象，直接赋值返回
- 最后再把新属性变成响应式，并派发更新

```js
function set(target, key, val) {
    // 判断是否是数组
    if (Array.isArray(target)) {
        // 判断谁大谁小
        target.length = Math.max(target.length, key)
        // 执行splice
        target.splice(key, 1, val)
        return val
    }

    const ob = target.__ob__

    // 如果此对象没有不是响应式对象，直接设置并返回
    if (key in target && !(key in target.prototype) || !ob) {
        target[key] = val
        return val
    }

    // 否则，新增属性，并响应式处理
    defineReactive(target, key, val)
    return val
}

//defineReactive 为vue源码
//get和set方法
function defineReactive(target,key,value){
    observer(value)//递归观察
    Object.defineProperty(target,key,{
        get(){
            //需要进行依赖收集
            return value
        },
        set(newValue){
            if(value !== newValue){
                observer(newValue)//更新后的数据也需要递归观察
                updataView();
                value = newValue
            }
        }
    })
}
```

# Vue.$delete

删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。

```js
function del (target, key) {
    // 判断是否为数组
    if (Array.isArray(target)) {
        // 执行splice
        target.splice(key, 1)
        return
    }

    const ob = target.__ob__

    // 对象本身就没有这个属性，直接返回
    if (!(key in target)) return


    // 否则，删除这个属性
    delete target[key]

    // 判断是否是响应式对象，不是的话，直接返回
    if (!ob) return
    // 是的话，删除后要通知视图更新
    ob.dep.notify()
}
```



# Sleep

## setTimeout 封装

```html
<script>
  function fnA() {
    console.log('A');
  }
  function fnB() {
    console.log('B');
  }
  function fnC() {
    console.log('C');
  }
  // sleep 函数
  function sleep(fun, time) {
    setTimeout(() => {
      fun();
    }, time);
  }
  sleep(fnA, 1000); // 1 秒后输出 A
  sleep(fnB, 2000); // 2 秒后输出 B
  sleep(fnC, 3000); // 3 秒后输出 C
</script>
```

缺点就是它**不会阻塞同步任务**

```js
sleep(fnA, 1000);
console.log('E');
sleep(fnB, 2000);
console.log('G');
sleep(fnC, 3000);
// 输出结果为 EGABC
```

## Promise封装

```html
<script>
  function fnA() {
    console.log('A');
  }
  function fnB() {
    console.log('B');
  }
  function fnC() {
    console.log('C');
  }


  // sleep 函数--Promise 版本
  function sleep(time) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, time);
    });
  }
  sleep(1000).then(fnA); // 1 秒后输出 A
  sleep(2000).then(fnB); // 2 秒后输出 B
  sleep(3000).then(fnC); // 3 秒后输出 C
</script>
```

缺点就是它**也不会阻塞同步任务**

## async/await

```html
<script>
  function fnA() {
    console.log('A');
  }
  function fnB() {
    console.log('B');
  }
  function fnC() {
    console.log('C');
  }
  // sleep 函数--Promise 版本
  function sleep(time) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, time);
    });
  }
  async function sleepTest() {
    fnA();                // 输出 A
    await sleep(1000);    // 睡眠 1 秒
    console.log('E');     // 输出 E
    fnB();                // 输出 B
    await sleep(1000);    // 睡眠 1 秒
    fnC();                // 输出 C
    await sleep(1000);    // 睡眠 1 秒
    console.log('G');     // 输出 G
  }
  sleepTest();
</script>
```

特点就是**可以阻塞同步任务**

# Ajax基础和手写Ajax函数

AJAX是异步的JavaScript和XML（**A**synchronous **J**avaScript **A**nd **X**ML）。简单点说，就是使用 `XMLHttpRequest` 对象与服务器通信。

AJAX最主要的两个特性：

- 在不重新加载页面的情况下发送请求给服务器。
- 接受并使用从服务器发来的数据。

AJAX的核心是`XMLHttpRequest`。
一个完整的`AJAX`请求一般包括以下步骤：

- 实例化`XMLHttpRequest`对象
- 连接服务器
- 发送请求
- 接收响应数据

```js
function ajax(option) {//type,url,obj,timeout,success,error将所有参数换成一个对象{}
    //  0.将对象转换成字符串
    var str = objToString(option.data);
    //  1.创建一个异步对象xmlhttp；
    var xmlhttp, timer;
    if (window.XMLHttpRequest) {
        xmlhttp = new XMLHttpRequest();
    } else {// code for IE6, IE5 
        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    }
    //  2.设置请求方式和请求地址； 
    // 判断请求的类型是POST还是GET
    if (option.type.toLowerCase() === 'get') {
        xmlhttp.open(option.type, option.url + "?t=" + str, true);
        //  3.发送请求；
        xmlhttp.send();
    } else {
        xmlhttp.open(option.type, option.url, true);
        // 注意：在post请求中，必须在open和send之间添加HTTP请求头：setRequestHeader(header,value);
        xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        //  3.发送请求；
        xmlhttp.send(str);
    }
    //  4.监听状态的变化；
    xmlhttp.onreadystatechange = function () {
        clearInterval(timer);
        if (xmlhttp.readyState === 4) {
            if (xmlhttp.status >= 200 && xmlhttp.status < 300 || xmlhttp.status == 304) {
                //  5.处理返回的结果；
                option.success(xmlhttp);//成功后回调；
            } else {
                option.error(xmlhttp);//失败后回调；
            }
        }
    }
    //处理obj 
    function objToString(data) {
        data.t = new Date().getTime();
        var res = [];
        for (var key in data) {
            //需要将key和value转成非中文的形式，因为url不能有中文。使用encodeURIComponent();
            res.push(encodeURIComponent(key) + " = " + encodeURIComponent(data[key]));
        }
        return res.join("&");
    }
    //判断外界是否传入了超时时间
    if (option.timeout) {
        timer = setInterval(function () {
            xmlhttp.abort();//中断请求
            clearInterval(timer);
        }, timeout);
    }
}
```

# 使用Promise封装Ajax请求

```javascript
// promise 封装实现：
function getJSON(url) {
  // 创建一个 promise 对象
  let promise = new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest();
    // 新建一个 http 请求
    xhr.open("GET", url, true);
    // 设置状态的监听函数
    xhr.onreadystatechange = function() {
      if (this.readyState !== 4) return;
      // 当请求成功或失败时，改变 promise 的状态
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    // 设置错误监听函数
    xhr.onerror = function() {
      reject(new Error(this.statusText));
    };
    // 设置响应的数据类型
    xhr.responseType = "json";
    // 设置请求头信息
    xhr.setRequestHeader("Accept", "application/json");
    // 发送 http 请求
    xhr.send(null);
  });
  return promise;
}
```

# axios

## 基本使用方式

```js
axios([config])
axios(url,[config])
axios.get/delete/head/options(url,[config])
axios.post/put/patch(url,[data],[config]
```

axios基本使用方式主要有

1. axios(config)
2. axios.method(url, data , config)

```html
// index.html文件
<html>
<script type="text/javascript" src="axios"></script>
<body>
<button class="btn">点我发送请求</button>
<script>
    document.querySelector('.btn').onclick = function() {
        // 分别使用以下方法调用，查看myaxios的效果
        axios.post('/postAxios', {
          name: '小美post'
        }).then(res => {
          console.log('postAxios 成功响应', res);
        })

        axios({
          method: 'post',
          url: '/getAxios'
        }).then(res => {
          console.log('getAxios 成功响应', res);
        })
    }
</script>
</body>
</html>
</html>
```

## 实现axios

### axios(config)形式的实现

从axios(config)的使用上可以看出导出的axios是一个方法。从axios.method(url, data , config)的使用可以看出导出的axios上或者原型上挂有get，post等方法

实际上导出的axios就是一个Axios类中的一个方法。

如代码所以，核心代码是request。我们把request导出，就可以使用axios(config)这种形式来调用axios了。

```js
class Axios {
    constructor() {

    }
    request(config) {
        return new Promise(resolve => {
            const {url = '', method = 'get', data = {}} = config;
            // 发送ajax请求
            const xhr = new XMLHttpRequest();
            xhr.open(method, url, true);
            xhr.onload = function() {
                console.log(xhr.responseText)
                resolve(xhr.responseText);
            }
            xhr.send(data);
        })
    }
}
```

导出方法，new Axios，获得axios实例，再获得实例上的request方法就好了。

```js
// 最终导出axios的方法，即实例的request方法
function CreateAxiosFn() {
    let axios = new Axios();
    let req = axios.request.bind(axios);
    return req;
}

// 得到最后的全局变量axios
let axios = CreateAxiosFn();
```

### axios.method()形式的实现

1、在Axios.prototype添加这些方法，然后在这些方法内部调用request方法

```js
// 定义get,post...方法，挂在到Axios原型上
const methodsArr = ['get', 'delete', 'head', 'options', 'put', 'patch', 'post'];
methodsArr.forEach(met => {
    Axios.prototype[met] = function() {
        console.log('执行'+met+'方法');
        // 处理单个方法
        if (['get', 'delete', 'head', 'options'].includes(met)) { // 2个参数(url[, config])
            return this.request({
                method: met,
                url: arguments[0],
                ...arguments[1] || {}
            })
        } else { // 3个参数(url[,data[,config]])
            return this.request({
                method: met,
                url: arguments[0],
                data: arguments[1] || {},
                ...arguments[2] || {}
            })
        }
    }
})
```

2、导出的是request方法，但是现在只是在Axios的prototype上添加对应的方法，所以需要将Axios.prototype上的方法搬运到request上，**实现一个工具方法，将b的方法混入a;**

```js
const utils = {
  extend(a,b, context) {
    for(let key in b) {
      if (b.hasOwnProperty(key)) {
        if (typeof b[key] === 'function') {
          a[key] = b[key].bind(context);
        } else {
          a[key] = b[key]
        }
      }
    }
  }
}
```

3、修改之前的`CreateAxiosFn`方法

```js
function CreateAxiosFn() {
  let axios = new Axios();
  
  let req = axios.request.bind(axios);
  // 增加代码
  utils.extend(req, Axios.prototype, axios)
  
  return req;
}
```

## 请求和响应拦截器

拦截器的使用

```js
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
  });
```

拦截器是什么意思呢？其实就是在我们**发送一个请求的时候会先执行请求拦截器的代码**，然后再真正地执行我们发送的请求，这个过程会对config，也就是我们发送请求时传送的参数进行一些操作。

而当接收响应的时候，**会先执行响应拦截器的代码**，然后再把响应的数据返回来，这个过程会对response，也就是响应的数据进行一系列操作。

### 实现

1、定义拦截器类

```js
class InterceptorsManage {
  constructor() {
    this.handlers = [];
  }

  use(fullfield, rejected) {
    this.handlers.push({
      fullfield,
      rejected
    })
  }
}
```

是用这个语句`axios.interceptors.response.use`和`axios.interceptors.request.use`，来触发拦截器执行use方法的。

可见，axios实例上有一个对象interceptors。这个对象有两个拦截器，一个用来处理请求，一个用来处理响应。

2、Axios中新增对象interceptors

```js
class Axios {
    constructor() {
        //新增代码
        this.interceptors = {
            request: new InterceptorsManage,
            response: new InterceptorsManage
        }
    }

    request(config) {
        return new Promise(resolve => {
            const {url = '', method = 'get', data = {}} = config;
            // 发送ajax请求
            console.log(config);
            const xhr = new XMLHttpRequest();
            xhr.open(method, url, true);
            xhr.onload = function() {
                console.log(xhr.responseText)
                resolve(xhr.responseText);
            };
            xhr.send(data);
        })
    }
}
```

我们执行语句`axios.interceptors.response.use`和`axios.interceptors.request.use`的时候，实现获取axios实例上的interceptors对象，然后再获取response或request拦截器，再执行对应的拦截器的use方法。

而执行use方法，会把我们传入的回调函数push到拦截器的handlers数组里。

因为interceptors对象是Axios上的啊，导出的是request方法，所以也需要将interceptors对象挂载到request上。

3、将interceptors对象挂载到request上。

```js
function CreateAxiosFn() {
  let axios = new Axios();
  
  let req = axios.request.bind(axios);
  // 混入方法， 处理axios的request方法，使之拥有get,post...方法
  utils.extend(req, Axios.prototype, axios)
  //新增代码
  utils.extend(req, axios)
  return req;
}
```

在我们发送请求的时候，会先获取request拦截器的handlers的方法来执行。再执行我们发送的请求，然后获取response拦截器的handlers的方法来执行。

4.更改request

```js
request(config) {
    this.sendAjax(config)
}
sendAjax(config){
    return new Promise(resolve => {
        const {url = '', method = 'get', data = {}} = config;
        // 发送ajax请求
        console.log(config);
        const xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        xhr.onload = function() {
            console.log(xhr.responseText)
            resolve(xhr.responseText);
        };
        xhr.send(data);
    })
}
```

4.获得handlers中的回调,同时再次修改request

```js
request(config) {
    // 拦截器和请求组装队列
    let chain = [this.sendAjax.bind(this), undefined] // 成对出现的，失败回调暂时不处理

    // 请求拦截
    this.interceptors.request.handlers.forEach(interceptor => {
        chain.unshift(interceptor.fullfield, interceptor.rejected)
    })

    // 响应拦截
    this.interceptors.response.handlers.forEach(interceptor => {
        chain.push(interceptor.fullfield, interceptor.rejected)
    })

    // 执行队列，每次执行一对，并给promise赋最新的值
    let promise = Promise.resolve(config);
    while(chain.length > 0) {
        promise = promise.then(chain.shift(), chain.shift())
    }
    return promise;
}

```

我们先把sendAjax请求和undefined放进了chain数组里，再把请求拦截器的handlers的成对回调放到chain数组头部。再把响应拦截器的handlers的承兑回调反倒chain数组的尾部。

然后再 逐渐取数 chain数组的成对回调执行。

```js
promise = promise.then(chain.shift(), chain.shift())
```

这一句，实际上就是不断将config从上一个promise传递到下一个promise，期间可能回调config做出一些修改。

## 取消请求

axios支持两种方式的取消请求,

1.controller.abort()

2.CancelToken

## 使用

### controller.abort()的使用

```js
const controller = new AbortController();

axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// 取消请求
controller.abort()
```

### CancelToken的使用

而对于 Axios 来说，我们可以通过 Axios 内部提供的 `CancelToken` 来取消请求：

```javascript
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.post('/user/12345', {
  name: 'semlinker'
}, {
  cancelToken: source.token
})

source.cancel('Operation canceled by the user.'); // 取消请求，参数是可选的
```

此外，你也可以通过调用 `CancelToken` 的构造函数来创建 `CancelToken`，具体如下所示：

```javascript
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    cancel = c;
  })
});

cancel(); // 取消请求
```



## 取消请求实现

```js
//取消请求
class CancelToken{
  constructor(exactor){
        /**
        * 定义 resolvePromise
        * 新建promise实例
        * 将 promise的resolve方法赋值给 resolvePromise 目的是为了在promise对象外使用resolvePromise方法来改变对象状态
        */
    //将promise给cancel。防止多次重复cancel
    let resolvePromise;//promise实例的resolve方法
    this.promise=new Promise(resolve=>{
      resolvePromise=resolve;
    })
      
        /**
        * 将CancelToken实例赋值给reason
        * 给executor传入cancel方法，cancel可调用resolvePromise方法
        */
    this.reason=undefined;
    const cancel=message=>{
      if(this.reason){return}// 取消已响应 返回
      this.reason='cancel'+message;
      resolvePromise(this.reason);//改变this.promise为resolve状态，=resolve('message')
    }
    exactor(cancel)
  }
    
  throwIfRequested() {
    if (this.reason) {
      throw this.reason
    }
  }
  static source(){
    let cancel;//等于上面的cancel，是一个函数
    const token=new CancelToken(function exactor(c){
      cancel=c;
    });
    return {
      token,
      cancel
    }
  }
}
```



# 常用排序

## 堆排序

```js
var heapSort = function (arr, length) {
    buildHeap(arr, length)
    for (let i = length - 1; i >= 0; i--) {
        swap(arr, 0, i)
        heapify(arr, i, 0)
    }
}

var buildHeap = function (arr, length) {
    for (let i = Math.floor((length - 1) / 2); i >= 0; i--) {
        heapify(arr, length, i)
    }
}

var heapify = function (arr, length, i) {
    if (i > length) return
    let c1 = i * 2 + 1, c2 = i * 2 + 2, max = i
    if (c1 < length && arr[c1] > arr[max]) max = c1
    if (c2 < length && arr[c2] > arr[max]) max = c2
    if (max !== i) {
        swap(arr, i, max)
        heapify(arr, length, max)
    }
}

var swap = function (arr, i, j) {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

arr = [1, 3, 5, 2]
heapSort(arr, 4)
console.log(arr)
```

## 归并排序

```js
var sortArray = function (nums) {
    if (nums.length === 0) return nums
    const temp = new Array(nums.length).fill(0)
    mergeSort(nums, 0, nums.length - 1, temp)
    return nums
};

var mergeSort = function (arr, left, right, temp) {
    if (left >= right) return
    const mid = left + Math.floor((right - left) / 2)
    mergeSort(arr, left, mid, temp)
    mergeSort(arr, mid + 1, right, temp)
    merge(arr, left, mid, right, temp)
}

var merge = function (arr, left, mid, right, temp) {
    let i = left, j = mid + 1, k = left
    while (i <= mid && j <= right) {
        if (arr[i] < arr[j]) {
            temp[k++] = arr[i++]
        } else {
            temp[k++] = arr[j++]
        }
    }
    while (i <= mid) {
        temp[k++] = arr[i++]
    }
    while (j <= right) {
        temp[k++] = arr[j++]
    }
    for (let m = left; m <= right; m++) {
        arr[m] = temp[m]
    }
}
```

## 快速排序

```js
var quickSort = function(arr, left, right) {
    if (left >= right) return 
    let pivot = arr[left]
    let i = left, j = right
    while (i < j) {
        while (arr[j] >= pivot && i < j) j--
        arr[i] = arr[j]
        while (arr[i] <= pivot && i < j) i++
        arr[j] = arr[i]
    }
    arr[i] = pivot
    quickSort(arr, left, i - 1)
    quickSort(arr, i + 1, right)
}

// let a = [1, 3, 2 ,4]
// quickSort(a, 0, 3)
// console.log(a)
```



# arrToTree (listToTree)

```js
let arr = [
      { id: 0, name: '1', parent: -1, childNode: [] },
      { id: 1, name: '1', parent: 0, childNode: [] },
      { id: 99, name: '1-1', parent: 1, childNode: [] },
      { id: 111, name: '1-1-1', parent: 99, childNode: [] },
      { id: 66, name: '1-1-2', parent: 99, childNode: [] },
      { id: 1121, name: '1-1-2-1', parent: 112, childNode: [] },
      { id: 12, name: '1-2', parent: 1, childNode: [] },
      { id: 2, name: '2', parent: 0, childNode: [] },
      { id: 21, name: '2-1', parent: 2, childNode: [] },
      { id: 22, name: '2-2', parent: 2, childNode: [] },
      { id: 221, name: '2-2-1', parent: 22, childNode: [] },
      { id: 3, name: '3', parent: 0, childNode: [] },
      { id: 31, name: '3-1', parent: 3, childNode: [] },
      { id: 32, name: '3-2', parent: 3, childNode: [] }
    ]

    function arrToTree(arr, parentId) {
       // 判断是否是顶层节点，如果是就返回。不是的话就判断是不是自己要找的子节点
      const filterArr = arr.filter(item => {
        return parentId === undefined ? item.parent === -1 : item.parent === parentId
      })
       
      // 进行递归调用把子节点加到父节点的 childNode里面去
      filterArr.map(item => {
        item.childNode = arrToTree(arr, item.id)
        return item
      })
       
      return filterArr
    }
    
    console.log(arrToTree(arr, 0))

```

# 二维数组ToTree

例如：将下面的二维数组：

```javascript
var arr = [
    ["a", "aa", "aaa", "aaaa"],
    ["b", "bb", "bbb"],
    ["a", "ab", "aba"],
    ["a", "aa", "aab"]
]
```

转成下面树结构的对象数组：

```javascript
[{
    
    "name" : "a",
    "child" : [
        {
    
            "name" : "aa",
            "child" : [
                {
    
                    "name" : "aaa",
                    "child" : [
                        {
    
                            "name" : "aaaa",
                            "child" : []
                        }
                    ]
                },
                {
    
                    "name" : "aab",
                    "child" : []
                }
            ]
        },
        {
    
            "name" : "ab",
            "child" : [
                {
    
                    "name": "aba",
                    "child" : []
                }
            ]
        }
    ]
},
{
    
    "name": "b",
    "child" : [
        {
    
            "name" : "bb",
            "child" : [
                {
    
                    "name" : "bbb",
                    "child" : []
                }
            ]
        }
    ]
}]
```

代码如下：

```javascript
function toTree(arr) {
    
	const obj = {
    };
	const res = [];
	for (let i = 0; i < arr.length; i++) {
    
	    for (let j = 0; j < arr[i].length; j++) {
    
	        const item = arr[i][j];
	        if (!obj[item]) {
    
	            obj[item] = {
    
	                name: item,
	                child: [],
	            };
	        }
	        if (j > 0) {
    
	            const parent = obj[arr[i][j - 1]];
	            if (parent) {
    
	                if (parent.child.indexOf(obj[item]) < 0) {
    
	                    parent.child.push(obj[item]);
	                }
	            }
	        } else {
    
	            if (res.indexOf(obj[item]) < 0) {
    
	                res.push(obj[item]);
	            }
	        }
	    }
	}
	return res;
}

console.log(toTree(arr))
```

# 用setTimeout和clearTimeout实现setInterval与clearInterval

**SetInterval实现**

```js
let timeMap = {}
let id = 0 // 简单实现id唯一
const mySetInterval = (cb, time) => {
  let timeId = id // 将timeId赋予id
  id++ // id 自增实现唯一id
  let fn = () => {
    cb()
    timeMap[timeId] = setTimeout(() => {
      fn()
    }, time)
  }
  timeMap[timeId] = setTimeout(fn, time)
  return timeId // 返回timeId
}
```

`id` 值是全局变量 `timeMap` 里的一个键的内容；

为了存每个定时器的id，用闭包；

每次更新 `setTimeout` 的 `id` 并不是去更新 `timeId`，相应的，我们去更新 `timeMap[timeId]` 里的值。

为了保证 `timeId` 的唯一性，在这里我简单用了一个自增的全局变量 `id` 来保证唯一。

**ClearInterval实现**

由于 `mySetInterval` 返回的 `timeId` 并不是真正的 `setTimeout` 返回的 `id` ，所以并不能简单地通过 `clearTimeout(timeId)` 来清除计时器。

不过其实原理也是很类似的，我们只要能拿到真正的 `id` 就行了：

```bash
const myClearInterval = (id) => {
  clearTimeout(timeMap[id]) // 通过timeMap[id]获取真正的id
  delete timeMap[id]
}
```

# 实现 Promise.retry，成功后 resolve 结果，失败后在规定时间内重试，尝试超过一定次数才真正的 reject

```js
    Promise.retry = function (fn, times = 5, delay = 500) {
        return new Promise((resolve, reject) => {
            let index = 0;
            let action = function (resolve, reject) {
                fn().then(resolve).catch(err => {
                    if (times == 0) {
                        reject(err)
                    } else {
                        times--;
                        index++;
                        console.log(`已重试${index}次`)
                        setTimeout(() => {
                            action(resolve,reject)
                        }, delay)
                    }
                })
            }
            action(resolve,reject)
        })
    }
    function getData() {
        let num = (Math.floor(Math.random() * 10) + 1);
        return new Promise(((resolve, reject) => {
            if (num == 1) {
                resolve(num)
            } else {
                reject(num)
            }
        }))
    }
    Promise.retry(getData).then(res => {
        console.log(res)
    }).catch(err => {
        console.log(`失败。值为${err}`)
    })
```



# 实现一个带并发限制的异步调度器

```js
    //实现
	class Scheduler {
        constructor(max = 2) {
            this.max = max
            this.count = 0
            this.queue = []
        }
        add(p) {
            this.queue.push(p)
            this.start()
        }
        start() {
            if (this.count >= this.max || !this.queue.length) return
            this.count++
            this.queue.shift()().finally(() => {
                this.count--
                this.start()
            })
        }
    }
	//以下为题目给出的已知代码
    const timeout = (time) => new Promise(resolve => {
        setTimeout(resolve, time)
    })

    const scheduler = new Scheduler()
    const addTask = (time, order) => {
        scheduler.add(() => timeout(time).then(() => console.log(order)))
    }
    addTask(1000, '1');
    addTask(500, '2');
    addTask(300, '3');
    addTask(400, '4');
```

# 在 class 中使用 Symbol.iterator使对象可迭代

```js
class User{
    constructor(name, gender, lv){
        this.name = name;
        this.gender = gender;
        this.lv = lv;
    }
    
    *[Symbol.iterator](){
        let keys = Object.keys( this )
            ;
        
        for(let i = 0, l = keys.length; i < l; i++){
            yield {
                key: keys[i]
                , value: this[keys[i]]
            };
        }
    }
}

let zhou = new User('zhou', 'male', 1);

for(let {key, value} of zhou){
    console.log(key, value);
}
// 输出结果
// name zhou
// gender male
// lv 1
```

# URL 解析

### URL 是什么样的

首先让我们看看一种完整的 URL 是长什么样的： `<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>`

如果这样太抽象了，那么我们举个例子具体化一下： `https://juanni:miao@www.foo.com:8080/file;foo=1;bar=2?test=3&miao=4#test`

| 组件          | 描述                                                         | 默认值       |                                                              |
| ------------- | ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ |
| scheme        | 访问服务器获取资源时使用的协议                               | 无           | https                                                        |
| user          | 访问资源时使用的用户名                                       | 无（匿名）   | juanni                                                       |
| password      | 用户的密码，和用户名使用`:`分割                              | E-mail       | miao                                                         |
| host          | 资源服务器主机名或IP地址                                     | 无           | [www.foo.com](https://link.juejin.cn/?target=http%3A%2F%2Fwww.foo.com) |
| port          | 资源服务器监听的端口，不同的scheme有不同的默认端口（HTTP使用80作为默认端口） | 和scheme有关 | 8080                                                         |
| path          | 服务器上的资源路径。路径与服务器和scheme有关                 | 默认值       | /file                                                        |
| params        | 在某些scheme下指定输入参数，是键值对。可以有多个，使用`;`分割，单个内的多个值使用`,` 分割 | 默认值       | foo=1;bar=2                                                  |
| query         | 该组件没有通用的格式，HTTP中打多使用`&`来分隔多个query。使用`?`分隔query和其他部分 | 无           | test=3&miao=4                                                |
| frag/fragment | 一小片或一部分资源名称。引用对象时，不会将fragment传送给服务器，客户端内部使用。通过`#`分隔fragment和其余部分 |              |                                                              |

### 获取每个部分

#### URLUtils

```javascript
function URLParser(url) {
    const a = document.createElement('a');
    a.href = url;
    return {
        protocol: a.protocol,
        username: a.username,
        password: a.password,
        hostname: a.hostname, // host 可能包括 port, hostname 不包括
        port: a.port,
        pathname: a.pathname,
        search: a.search,
        hash: a.hash,
    }
}
```

缺点：

- 依赖浏览器宿主环境接口

#### 使用 `URL` 对象

```js
function URLParser(url) {
    const urlObj = new URL(url);
    return {
        protocol: urlObj.protocol,
        username: urlObj.username,
        password: urlObj.password,
        hostname: urlObj.hostname,
        port: urlObj.port,
        pathname: urlObj.pathname,
        search: urlObj.search,
        hash: urlObj.hash,
    }
}
```

#### 正则

```js
function parseUrl(url) {
    var pattern = RegExp("^(?:([^/?#]+))?//(?:([^:]*)(?::?(.*))@)?(?:([^/?#:]*):?([0-9]+)?)?([^?#]*)(\\?(?:[^#]*))?(#(?:.*))?");
    var matches =  url.match(pattern) || [];
    return {
        protocol: matches[1],
        username: matches[2],
        password: matches[3],
        hostname: matches[4],
        port:     matches[5],
        pathname: matches[6],
        search:   matches[7],
        hash:     matches[8]
    };
}
parseUrl("https://juanni:miao@www.foo.com:8080/file;foo=1;bar=2?test=3&miao=4#test")
```

![](pics/url解析.png)

### 解析 search(query) 部分

#### 使用 URLSearchParams

```js
function getUrlQueyr(search) {
    const searchObj = {};
    for (let [key, value] of new URLSearchParams(search)) {
        searchObj[key] = value;
    }
    return searchObj;
}
```

优点：

- 不需要手动使用 `decodeURIComponent`
- 会帮着把 query 上的 + 自动转换为空格（单独使用 `decodeURIComponent` 做不到这点）（至于什么情况把 空格 转换为 `+` ，什么情况把空格转换为 `%20`，可以[参考这里等](https://link.juejin.cn/?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2678551%2Fwhen-to-encode-space-to-plus-or-20)）
- 不支持如 `array[]` / `obj{}` 等形式

#### 正则

^ :开头

$ :结尾

| :或者

(^|&) : &或者[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)的开头

([^&]*) :任意个不含&的字符

(&|$) :&或者字符串的结尾

如：获取网址中的code参数：

解析url中的查询参数

字符串开头或者&符号开头，加上参数变量的内容，再加上任意个不含&的字符，以&或字符串结尾

```javascript
var query = getQueryString(window.location.search, "code")
function getQueryString (queryString, name) {
    var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
    var r = queryString.substr(1).match(reg);
    if (r != null) {
        return decodeURI(r[2]);
    }
    return null;
}
```

 

# 实现一个打乱数组的方法

最佳的打乱算法是Fisher-Yates算法，下面是一个简单实现

```js
const arr = [0, 1, 2, 3, 4];
for (let i = 1; i < arr.length; i++) {
    const random = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[random]] = [arr[random], arr[i]];
}
```
