# 如何自学前端

## **首先，了解前端路线，制定大致学习计划**

### 前端基础

- HTML
- CSS
- Javascript

### 计算机基础

- 计算机网络
- 数据结构与算法

### 常用框架

- Vue
- React
- Angular
- jQuery
- Bootstrap

### 打包工具

- webpack
- vite

### 浏览器

- 浏览器工作原理
- 浏览器渲染机制

## 不同的学习方法

### 第一阶段：基础学习

HTML CSS：基础，看视频+看W3School，了解基本的选择器，进行简单的布局，了解定位，浮动，bfc等

JavaScript基础：看JS高级程序设计，学习基础，ECMA+BOM+DOM

### 第二阶段：加深

HTML5：HTML5新语义标签、Web视频

CSS3:CSS3新选择器、伪元素、边框、阴影、Transition、动画

计算机网络：《Web性能权威指南》HTTP、TCP/IP

ES6：const let var 、箭头函数、promise、闭包，原型，事件循环机制《阮一峰ES6标准入门》

### 第三阶段：框架和浏览器

VUE框架，官网＋视频

搭建vue2 demo

vue响应式原理，生命周期，diff算法

webpack+npm

浏览器的渲染过程、浏览器垃圾回收机制、跨域

### 第四阶段：上手项目

项目，西奥项目和个人组件库项目

西奥项目：elementUI和ECharts，websocket和**前端性能优化**

个人组件库项目：组件间通信，**单元测试**



## 保持技术敏感度

我基本每天早晚会抽出30分钟，浏览一些论坛和前沿技术博客，比如思否掘金知乎 等。时刻保持自己对技术的敏感度。

**大厂团队关注**

- [阿里`UED`](https://link.juejin.cn/?target=http%3A%2F%2Fwww.aliued.com%2F%3Fcat%3D14)
- [滴滴 `FE BLOG`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FDDFE%2FDDFE-blog)
- [头条前端](https://link.juejin.cn/?target=https%3A%2F%2Ftechblog.toutiao.com%2Ftag%2F%E5%89%8D%E7%AB%AF%2F)
- [有赞前端](https://link.juejin.cn/?target=https%3A%2F%2Ftech.youzan.com%2Ftag%2Ffront-end%2Fpage%2F2%2F)
- [腾讯 `AlloyTeam`](https://link.juejin.cn/?target=http%3A%2F%2Fwww.alloyteam.com%2Fpage%2F0%2F)
- [腾讯 `TNFE`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTnfe%2FTNFE-Weekly)
- [百度 `EFE`](https://link.juejin.cn/?target=https%3A%2F%2Fefe.baidu.com%2F)
- [HYPERS 前端团队博客](https://link.juejin.cn/?target=https%3A%2F%2Fblog.rsuitejs.com%2F)
- [InfoQ 前端专栏](https://link.juejin.cn/?target=https%3A%2F%2Fwww.infoq.cn%2Ftopic%2F33)
- [印记中文周刊](https://link.juejin.cn/?target=https%3A%2F%2Fweekly.docschina.org%2Fjavascript)
- [阮一峰老师weekly](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fruanyf%2Fweekly)
- [蚂蚁数据体验技术团队](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FProtoTeam%2Fblog)
- [TNFE-Weekly](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTnfe%2FTNFE-Weekly)

## 善用工具

### **LightHouse**

### devtools

### JEST

### 阿里iconfont

## 多看官网



# 对前端的看法

## 按领域分

按领域分，可以分为 前端基础、PC端技术、移动端技术、服务端技术、优化、前端监控、前端工程化技术

### 前端基础

- HTML
- CSS
- Javascript

### **PC 端技术**

对于现在的 PC 端来说，内容分成两块：

1. 以 jQuery 为代表的一系列高兼容性框架（或者说是库）
2. MVVM 框架，如 Angular、React、Vue），这一块内容，以 Vue 为例进行解释

#### **以 jQuery 为代表的一系列高兼容性框架（或者说是库）**

虽然jQuery非常老，跟不上时代发展的潮流，但是因为一些历史遗留问题或者业务兼容问题（IE9浏览器兼容），还是有很多的基于jQuery的系统在运作和维护。

#### **以 Vue 为例的一系列 MVVM 框架**

1.根据渲染模式的不同，我们需要了解两部分：

1. 单页应用：SPA
2. 基于服务端的渲染：SSR

2.Vue 全家桶知识：

1. 路由管理：VueRouter
2. 全局状态管理：Vuex
3. 脚手架工具：@vue/cli

3.组件库部分：

1. 比如：Element-UI
2. 比如：Vuetify
3. 比如：vant-ui

当然除了这些之外，其他的周边库还有很多，比如 网络请求库：axios 等等，这些都是需要大家去进行掌握的。

### **移动端技术**

对于移动端技术来说，目前主要有两个方向：

1. 以 微信小程序 为代表的小程序技术
2. 跨平台技术

#### **以 微信小程序 为代表的小程序技术**

微信作为国民应用，推出的小程序现在也很火热，小程序最初以 原生 的方式进行开发，后来逐渐出现了一批基于小程序的框架，如果你是一个小程序开发为主的前端工程师，那么以下知识点，你是必须要掌握的：

1. 小程序原生开发
2. 小程序框架开发（比如：wepy、mpvue）
3. 小程序 UI 库（比如：WeUI、Vant weapp、iView weapp）

#### **跨平台技术**

跨平台技术的提出主要是为了解决 **移动端设备碎片化** 的问题，移动端设备碎片化就是因为

目前移动端的设备，主要分成两块
1、Android
2、IOS
而对于任何一端来说，又分为 **原生应用**（APP） 和 **网页应用** ，同时还多了一个 **小程序**（虽然小程序的设计之初也有为了解决 移动端设备碎片化 问题的原因） 。
如果我们为每一种应用方式都开发一个版本的话，那么我们就需要大约 4 个应用的维护。这样的一个成本是任何一家中小型企业都难以接受的。
所以大家一直期望，有一种方式可以开发一个应用，但同时运行在多个设备之中。

**跨平台技术的出现，旨在解决 一个项目无法同时作用于多种不同设备之上 的问题。**

整个跨平台技术方案中，目前主要流行的有以下 4 种：

1. React Native
2. Flutter
3. Weex
4. uni-app (一套代码编到8个平台)

### **服务端技术**

服务端技术 可能在你的初期对你帮助不大，但是当你在技术领域越来越深入的时候，它是必不可少的内容。

四个方面：Node.js 、数据库知识、服务器、云概念

#### Node.js

大体可以分成两个框架方向：

1. Express
2. KOA

#### 数据库知识

目前的数据库同样分成了两块大的方向：

1. SQL 型数据库，推荐：MySql
2. NO SQL 型数据库，推荐：MongoDB，Redis

#### 服务器

1. Apache
2. Nginx (重点推荐)，针对于 Nginx 来说，你至少需要掌握两点：

1.单页应用的部署

2.反向代理 / 跨域处理

#### 云概念

（个人认为：云概念是未来的主要方式），云概念至少需要掌握以下 5 点：

1.**云服务器**

1.标准 ECS 云服务器

2.应用云服务器

2.**云数据库**

1.SQL 型

2.NO SQL 型

3.**云存储服务**

1.OSS：对象存储

2.NAS：文件存储

4.ServerLess：无服务结构（小程序云开发是一个很好的切入点）

5.CDN 服务

### **优化技术**

优化技术主要 针对网页访问速度的优化 和 用户误操作规避的优化，

列举几个方向：

1. 静态资源优化
2. 接口访问优化
3. 页面渲染速度优化
4. 防抖 / 节流方案

### **监控技术**

什么叫做监控技术呢？

> 当我们的项目上线之后：
> 到底有多少人来访问？
> 项目出现过多少次catch？
> 用户在哪个页面停留的时间比较长？
> 等等…

获取这些数据的方式我们就称为：**数据监控技术**，这里简称 **监控技术**。

你如果只作为一个码农角色的话，那么确实没有用。但是如果你站在**开发者**的角度、或者 **项目所有人** 的角度来看的话，那么这些数据是非常重要的依据。基于这些数据来完成的 **数据可视化平台** ，也是现在非常重要的一个方向。

实现数据监控的方式主要可以分成两种：

1. 自定义数据监控
2. 使用现成的第三方监控平台（前期推荐使用）

如果你对监控技术刚刚接触，或者处于项目前期的话，那么我个人推荐你使用 现成的第三方监控平台，这一类的平台有很多，简单列出三个：

1. 百度统计
2. 诸葛IO
3. GrowingIO

### **工程化技术**

什么是工程化呢？

> 比如说：
> 你的代码提交到 Git ，那么这个 Git 平台是怎么搭建的？
> 你的代码提交，如果不合规（死链或者代码格式不合规），如何避免被提交？
> 代码部署这种重复的工作如何自动化？
> 新版本上线如何最大程度的减轻 BUG 出现导致大面积崩溃的风险？
> 如果真的出现了大面的崩溃，如何快速的返回上一个稳定版本？
> 等等…

这些场景，我们都可以称之为是属于 **前端工程化** 的一部分

工程化代表的应该是一整套前端从开发到上线的全流程。目前的工程化以自动工程化为主。也就是说你的开发、测试、部署等等，全部都自动化。

工程化技术方面，简单的给大家进行一下列举：

1.代码托管平台搭建

1.Gitlab

2.自动化工具

1.合规检测

1.ESLint 提交检测

2.兼容性检测

3.死链检测

2.自动化测试

3.自动化部署

1.CI：持续集成

2.CD：持续部署

3.产品迭代方面

1.灰度发布

2.A/B 测试

## 职位来分

前端工程师分为

前端游戏

前端架构

pc前端

移动前端

node工程师

重构和js工程师

可视化，webgl、业务、babel、网页设计

# 未来规划/发展计划

## 第一阶段

**熟练掌握基本知识**

1. HTML + CSS ：这是基础中的基础，是必须要掌握的
2. JavaScript： JS 作为前端的核心语言，用来处理所有逻辑相关的问题，是入门前端的一个必备内容

## 第二阶段

**工作知识的掌握**

vue生态：vue、vueX、vueRouter、周边库（echarts）、UI库、组件库等（**看公司业务去具体学习，通过阅读源码加深理解**）

TypeScript+vite+vue3

跨域，模块化

工具：

包管理npm、转译babel、构建webpack rollup、质量检查eslint csslint 、版本控制git、 自动化测试 单元测试 界面功能测试

学习**小程序技术** 和 **跨平台技术** 

浏览器机制，缓存、渲染

**前端工程化** 

工程化代表的应该是一整套前端从开发到上线的全流程。目前的工程化以自动工程化为主。也就是说你的开发、测试、部署等等，全部都自动化。

工程化技术方面，简单的给大家进行一下列举：

1.代码托管平台搭建

1.Gitlab

2.自动化工具

1.合规检测

1.ESLint 提交检测

2.兼容性检测

3.死链检测

2.自动化测试

3.自动化部署

1.CI：持续集成

2.CD：持续部署

3.产品迭代方面

1.灰度发布

2.A/B 测试

**Node.js**

大体可以分成两个框架方向：

1. Express
2. KOA

**数据库知识**

目前的数据库同样分成了两块大的方向：

1. SQL 型数据库，推荐：MySql
2. NO SQL 型数据库，推荐：MongoDB，Redis

**服务器**

1. Apache
2. Nginx (重点推荐)，针对于 Nginx 来说，你至少需要掌握两点：

**云概念**

## 第三阶段

进阶知识 和 底层知识

1.TypeScript

2.ES6

3.CSS 预处理器

1.Scss

2.Less

3.Stylus

4.**思想层面**

1.组件化思想

2.数据驱动思想

设计思想

计算机网络体系

数据结构和算法和实际

**性能优化**，实际应用

数据监控技术

工程化技术

工程化代表的应该是一整套前端从开发到上线的全流程。目前的工程化以自动工程化为主。也就是说你的开发、测试、部署等等，全部都自动化。

**知道怎么用，并且知道为什么（阅读源码，经验积累）**



## 展望

### 大前端

现有的移动端（Android、IOS）原生开发工程师、小程序开发工程师都会逐渐的融入到前端的概念中，也就是共同组成 大前端

更笼统概念加上 服务端技术，优化技术，监控技术，工程化技术

### 微前端

`微前端（Micro-Frontends）` 并没有定义框架或 API，它其实是一个类似 **微服务架构** 的概念；**将 `微服务` 的概念扩展到了前端世界；**

以前端的角度一句话概括就是： `将您的大型前端应用拆分为多个小型前端应用，这样每个小型前端应用都有自己的仓库，可以专注于单一的某个功能；`

需要强调的是，尽管我们将前端应用拆分为多个项目，但它们最终还是会被集成到一个单页前端应用程序中；因此，通过使用微前端架构，您不会在用户体验上有任何损失，只会有过之而无不及；

**前端微前端架构图**

![微前端(1).png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9f3e7b9436b43aba7be574a355aef4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

通过这张图，我们就可以很明显的看得出来微前端架构就是在一个前端应用中塞进去多个子前端应用，这样就构成了最简单的微前端概念，也是最核心的概念；

### ServerLess概念

ServerLess：无服务架构

Serverless 强调的是一种架构思想和服务模型，让开发者无需关心基础设施（服务器等），而是专注到应用程序业务逻辑上。Serverless 也是下一代计算引擎。

**Serverless的优势**

- 可用性冗余，以便单个机器故障不会导致服务中断
- 冗余副本的地理分布，以便在发生灾难时保留服务
- 负载平衡和请求路由以有效利用资源
- 响应负载变化进行自动缩放以扩展或缩小系统
- 监控以确保服务仍然运行良好
- 记录以记录调试或性能调整所需的消息
- 系统升级，包括安全修补
- 迁移到新实例时可用

**与其说Serverless是一项技术，不如说Serverless是一种理想的工作模式，是一种专注于业务价值的思考**。单纯的通过函数进行业务交付，而不再需要关心解决业务问题之外的事情，比如：那些非常繁琐的基础设施。托管服务可以让开发者更专注于编写业务函数，从而减少对机器资源、降低运维成本的考虑，可以让开发者更专注的为产品和用户创造价值。随着云厂商对于Serverless的支持，后续会有越来越多的开发者，可以体会到云时代给大家带来的便利。

开发者选择应用Serverless的场景有很多，比如：为小程序、Web、Mobile提供基础性的API服务，大规模批处理任务处理，Web站点、DevOps的工具以及GraphQLAPI能力。

### WebAssembly（WASM）

WebAssembly 或者 wasm 是一个可移植、体积小、加载快并且兼容 Web 的全新格式

**WebAssembly 是一种运行在现代网络浏览器中的新型代码**，并且提供新的性能特性和效果。它设计的目的不是为了手写代码而是为诸如 C、C++和 Rust 等低级源语言提供一个高效的编译目标。

对于网络平台而言，这具有巨大的意义——**这为客户端 app 提供了一种在网络平台以接近本地速度的方式运行多种语言编写的代码的方式**；在这之前，客户端 app 是不可能做到的。

而且，你在不知道如何编写 WebAssembly 代码的情况下就可以使用它。WebAssembly 的模块可以被导入的到一个网络 app（或 Node.js）中，并且暴露出**供 JavaScript 使用的 WebAssembly 函数**。JavaScript 框架不但可以使用 WebAssembly 获得巨大性能优势和新特性，而且还能使得各种功能保持对网络开发者的易用性。

**什么时候使用WebAssembly？**

总结下来，大部分情况分两个点。 - 对性能有很高要求的App/Module/游戏 - 在Web中使用C/C++/Rust/Go的库 举个简单的例子。如果你要实现的Web版本的Ins或者Facebook， 你想要提高效率。那么就可以把其中对图片进行压缩、解压缩、处理的工具，用C++实现，然后再编译回WebAssembly。

**是如何工作的**

第一步：你使用 C、C++ 或其他语言生成源代码，这段代码应该可以解决某个问题，或者完成某段对浏览器中的 JavaScript 来说太过复杂的流程。

第二步：使用 Emscripten 将你的源代码编译为 WebAssembly，这一步完成时，你将得到一个 wasm文件。

第三步：你将在网页上使用这个 wasm文件，将来你可以像其他 ES6 模块一样加载这个文件。

### 前端智能化

狭义的智能化利用深度学习技术，在图像、NlP等方向，通过模型训练、预测的方式的智能化， 广义前端智能化可以从输入到输出的角度思考。

近些年出现的代码分析工具 DeepCode，基于 GPT-3 的代码生成工具 Copilot，还有野心非常大的从自然语言到代码生产的 NL2Code 方向，都扩展了我们对于前端智能化的认知。

业界阿里在前端智能化上探索得较早，不仅取得了较多成果，而且界定了前端智能化的分级，为前端智能化的发展指明了方向： ![v2-a257e29258c552e6415452eafd635903_1440w.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09f287310c8f47f89c28b2e51afb3c41~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) 目前阿里 imgcook 的能力处于 D2C 的 L3 级别，智能生成的代码还需要可视化干预或人工兜底开发后验证上线；未来期望达到 L4 级别，需要对 UI 信息架构进行拆解，对从 UI 信息自动生成代码的智能化能力进行细分。

## 再展望

**web3.0 去中心化**

Web3的数字化生态，**在其中用户可以真正拥有自己的数据，并且交易受到了加密技术保障。**

用户无需再信任品牌背书，而是可以依赖确定的软件代码逻辑来严格执行协议。

- **区块链让数据成为资产**
- **智能合约打造可编程的智能经济体系**
- **人工智能构建全球智慧大脑并创造“数字人”**
- **物联网让物理世界的现实物体向数字空间广泛映射**
- **AR实现了数字世界与物理世界的叠加**
- **5G网络、云计算、边缘计算将构建更加宏伟的数字新空间**
- 元宇宙

所以我认为去中心化不是目的，去中心化带来的透明、自我可掌控、代码即真理才是目的。

用户可以掌握自己在互联网上的数据及数据资产、代码开源自由接入、资产在全球流动、数据公开透明等等。

## 前端工程师的选择

前端工程师分为

前端游戏

前端架构

pc前端

移动前端

node工程师

重构和js工程师

可视化，webgl、业务、babel、网页设计、seo

**前端架构师：**

**跨界**：真正的架构师是需要有跨界的能力的，随着技术的持续完善，这种通过岗位变迁实现技术架构升级的情况会越来越少。而架构层面新的变化将来自于岗位自发的对自身工作内容、职责的重新定义，也就是这里说的边界。所以说并不是你作为一个前端开发岗位，你就不能干前端之外的事了，要尝试跳出边界来思考和解决问题。

**尝鲜**：作为一个架构师，不断学习新的技术是非常重要的，这里所说的尝鲜，就是要对技术保持一定的热情，不能只满足于现状，说白了讲就是要不断的学。

**工具和平台化建设**：

可以看出来工具平台主要就是围绕我们的研发流程中的每一步关键节点去建设起来的，结合起来说，我们可以称之为工程化。工程化是这几年非常热门的概念，对前端来讲也是一个很明确的前端发展方向，其实工具平台的完善过程就是架构工程化的推进过程。

![img](https://pic4.zhimg.com/80/v2-17eb7cc852a5ced71770a029915e405d_720w.jpg?source=1940ef5c)

身为一名架构师，你需要有敏锐的嗅觉来洞悉这些节点。并且在适当的时机能够做出对业务有提升的工具平台，要做到遇到重复性的问题时，想想是不是开发出一款自动化工具平台来处理，这才是代码之外对业务提升解决方案。

**流程和规范化**：

这里的规范，总结起来可以分为成：

1. 结构的规范：对项目的代码结构，不管前后端，合理的分层和[组件化](https://www.zhihu.com/search?q=组件化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A815383194})是非常必要的。
2. 编码的规范：这里主要就是代码codereview了，定期的进行codeview的同时，最好可以使用一些自动化工具。
3. 流程的规范：项目的评审，研发，测试，发布这些阶段都需要有流程来约束，这些需要结合自身团队的实际情况来制定。
4. 规范的落地：对于规范来说最关键的是执行落地，在制定完规范的同事，要不时的回顾是否切实的落地，这个应该是团队里每个成员坚持的基本准则。

**方法论**：

所谓方法论，可能单单说起来是比较抽象的，这里的方法论，主要是指在完成一项小的需求，或者是承接一个重大的项目，在具体的实施过程中，要有一定的方法和技巧，

**安全意识**

这里为什么要把安全单独拿出来说呢，因为对于一个业务而言，安全是第一要素，就好比一个国家，安全稳定才是发展一切的前提，一旦业务出现安全问题，就可能瞬间损失掉全部，代价是非常惨重的。所以作为一名架构师，必须要保证业务的稳定性，可以总结以下几点：

1. 对低级的的代码安全问题，要坚决说不，例如前端里面的xss，[csrf](https://www.zhihu.com/search?q=csrf&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A815383194})这些问题。
2. 对大型运营类活动需求，要有容灾意识和**备份**，例如在准备了一套方案的同时，要有可选的备用方案。
3. 尝试使用工具化来解决和预防安全问题，例如BAT这种大型企业，在运维和代码层面，都有一层保障机制，如腾讯的门神系统等。

**团队合作**

所以团队合作的目的就是让团队中的每个人都能明确自己的职责，并发挥出最大的价值，架构师有义务来维护这种合作关系。并且对你的认同，也是团队成员赋予你的，维护良好的氛围，才能让团队成员信服。



# 分号问题

### 分号的作用

分号也是一个执行语句，叫做**空语句**，分号是断句用的，每一个分号就是一个程序语句结束的标志。

### ASI（**自动插入分号机制**）

抽象语法树中并没有分号这个东西。**插入分号只是一个概念，意思是解析器除了分号，还会把换行符当作断句的依据，从而保证语句解析的正确性，并不是真的往里插一个分号**（当然了，你本地压缩代码的时候，emmm，应该是需要真的插入的）。

但是ASI并不是将所有的换行符都识别成分号，而是通过以下规则。

#### ASI的插入规则

大前提，ASI的纲领：

- 以换行为基础。（就是你肯定得有换行符才行）
- JS解析器是尽量把语句合并成同一行的解析的。只有符合ASI规则的时候，才会加入分号进行断句

#### 什么情况下不会触发ASI了

就一句

新的一行以(， [， /， +， -， ， %， ,， .开头

因为这些符号开头的话，根据上述的ASI的第一条规则，这一行和上一行并成一行的时候，并不会形成非法语句。例如`[]`会被识别成属性。`()`会被识别成函数执行语句。

解决方法就是在新一行的开始，手动加一个分号即可。

### 到底应该加不加分号呢

加不加分号 一看个人习惯喜好，二看**团队要求**。规范上加不加并没有对错之分，但是你都要对ASI了解。

**但是加分号，有可能会误导或扰乱ASI的解析机制，发生预想不到错误或bug。**

例子：

```js
//所有 JavaScript 开发者都必须了解 ASI，即使是那些「总是使用分号」的人。举个例子：
function foo () {
  return
    {
      bar: 1,
      baz: 2
    };
}
//哇哦，虽然你记得在最后添加分号，但这无关紧要。ASI 会强行介入并把你的代码修改为：
function foo () {
  return; // <-- ASI 在这里插入了一个分号。现在你的代码出现了一个 bug！
    {
      bar: 1,
      baz: 2
    };
}
```

# 页面出现长时间的白屏要怎样排查问题？

## 从网络方面检测

1. 先确保网络连接顺畅
2. 再检查 `URL` 地址是否错误
3. 打开 `控制台` 查看是否有报错信息
4. 查看`接口访问` 是否有请求
5. 查看 `路由` 是否有 `path错误` ，导致加载了不存在的页面

## 从js和css方面检测

排除了 `网络问题` 以后，如果还是白屏，那一般都是 `css和js` 加载造成的；`css和js` 会造成`阻塞渲染`。比如不正确的引入`css和js` ， 就会导致它们的加载速度过长，从而导致白屏现象。
正确的引入方式是：

1. 在 `<head>` 标签中引入`css`：因为在加载`HTML` 前不先渲染`css` 的话，整个页面会乱掉；
2. 在 `</body>` 标签之前、`body` 标签中`html` 内容的`后面` ，引入 `js`：因为浏览器加载`script` 标签时，处理内部代码的顺序都是`从上到下` 依次执行的，如果在 `html` 内容前就引入`js` 的话，那么就会导致，在所有的代码处理完毕之前，会阻塞其他资源的加载；会导致页面的其他内容都无法显示，因此如果不规范引入js的话，会对页面的其他内容带来影响。

**补充说明：**
`script` 标签里可以添加`async或defer` 属性，如果`不添加` 这个属性，浏览器就会`立即加载并执行`脚本；也就是在渲染`script` 标签之前，不等后续的文档加载前执行；他们的区别在于：

1. `async`：加载和渲染后续文档元素的过程将和 `script.js`的加载与执行并行进步（异步）
2. `defer`: 加载后续文档元素的过程中和`script.js`的加载与执行并行进步（异步）。但是`script.js`的执行要在所有元素解析完成之后，`DOMContentLoaded` 事件触发之前完成。

`defer` 和`async` 在`网络读取（下载）` 方面是一样的，都是`异步的` ；区别在于脚本下载完成之后什么时候开始执行。



# 前端如何实现高精度定时器

### 用setTimeout代替setInterval

setInterval 有**两个缺点**：

- 使用 setInterval 时，**某些间隔会被跳过**；
- 可能多个定时器**会连续执行**；

可以这么理解：**每个 setTimeout 产生的任务会直接 push 到任务队列中；而 setInterval 在每次把任务 push 到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中，如果有则不添加，没有则添加)。**

因而我们一般用 setTimeout 模拟 setInterval，来规避掉上面的缺点。
