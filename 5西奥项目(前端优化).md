# 西奥项目

## 技术栈

Vuex+Vue Router+ Vuex+elementUI+ECharts

vue2.6  element-ui2.7 webpack5 vue/cli5

## 准备

### 创建项目

运行以下命令来创建一个新项目：

```
vue create xio
```

刚创建完的文件结构如图

![](pics/xio1.png)

### 修改文件结构

![](pics/xio2.png)

结构为

```sh
├── build                      # 构建相关
├── mock                       # 项目mock 模拟数据
├── public                     # 静态资源
│   │── favicon.ico            # favicon图标
│   └── index.html             # html模板
├── src                        # 源代码
│   ├── api                    # 所有请求
│   ├── assets                 # 主题 字体等静态资源
│   ├── components             # 全局公用组件
│   ├── icons                  # 项目所有 svg icons
│   ├── layout                 # 全局 layout
│   ├── router                 # 路由
│   ├── store                  # 全局 store管理
│   ├── styles                 # 全局样式
│   ├── utils                  # 全局公用方法
│   ├── views                  # views 所有页面
│   ├── App.vue                # 入口页面
│   └── main.js                # 入口文件 加载组件 初始化等
├── tests                      # 测试
├── .env.xxx                   # 环境变量配置
├── .eslintrc.js               # eslint 配置项
├── .babelrc                   # babel-loader 配置
├── .travis.yml                # 自动化CI配置
├── vue.config.js              # vue-cli 配置
├── postcss.config.js          # postcss 配置
└── package.json               # package.json
```

### 页面布局

在layout中

![](pics/xio3.png)

完成侧边栏Sidebar，主体Layout的页面显示

```vue
<template>
  <div :class="classObj" class="app-wrapper">
    <div v-if="device==='mobile'&&sidebar.opened" class="drawer-bg" @click="handleClickOutside" />
    <sidebar class="sidebar-container" />
    <div :class="{hasTagsView:needTagsView}" class="main-container">
      <div :class="{'fixed-header':fixedHeader}">
        <navbar />
        <tags-view v-if="needTagsView" />
      </div>
      <app-main />
      <right-panel v-if="showSettings">
        <settings />
      </right-panel>
    </div>
  </div>
</template>
```

上图为整个页面的html，各个组件都在layout下的components里面定义

其中AppMain中嵌套了一个路由，用于在router中切换显示，下图为AppMain

```vue
<template>
  <section class="app-main">
    <transition name="fade-transform" mode="out-in">
      <keep-alive :include="cachedViews">
        <router-view :key="key" />
      </keep-alive>
    </transition>
  </section>
</template>
```



### 路由设置

路由设置如下：

```js
// No layout
{
  path: '/401',
  component: () => import('errorPage/401')
}

// Has layout
{
  path: '/documentation',

  // 你可以选择不同的layout组件
  component: Layout,

  // 这里开始对应的路由都会显示在app-main中 如上图所示
  children: [{
    path: 'index',
    component: () => import('documentation/index'),
    name: 'documentation'
  }]
}
```

项目中开局为layout，除了401，404页面外，其他页面都为layout，然后使用嵌套路由在`app-main`这个主体区域中显示主体内容

具体的例子

```js
  {
    path: '/guide',
    component: Layout,
    redirect: '/guide/index',
    children: [
      {
        path: 'index',
        component: () => import('@/views/guide/index'),
        name: 'Guide',
        meta: { title: 'Guide', icon: 'guide', noCache: true }
      }
    ]
  },
```

使用redirect重定向

### 怎么让elementUi的侧边栏和路由所对应

官方侧边栏

```html
    <el-menu
      default-active="2"
      class="el-menu-vertical-demo"
      @open="handleOpen"
      @close="handleClose">
      <el-submenu index="1">
        <template slot="title">
          <i class="el-icon-location"></i>
          <span>导航一</span>
        </template>
        <el-menu-item-group>
          <template slot="title">分组一</template>
          <el-menu-item index="1-1">选项1</el-menu-item>
          <el-menu-item index="1-2">选项2</el-menu-item>
        </el-menu-item-group>
        <el-menu-item-group title="分组2">
          <el-menu-item index="1-3">选项3</el-menu-item>
        </el-menu-item-group>
        <el-submenu index="1-4">
          <template slot="title">选项4</template>
          <el-menu-item index="1-4-1">选项1</el-menu-item>
        </el-submenu>
      </el-submenu>
      <el-menu-item index="2">
        <i class="el-icon-menu"></i>
        <span slot="title">导航二</span>
      </el-menu-item>
      <el-menu-item index="3" disabled>
        <i class="el-icon-document"></i>
        <span slot="title">导航三</span>
      </el-menu-item>
      <el-menu-item index="4">
        <i class="el-icon-setting"></i>
        <span slot="title">导航四</span>
      </el-menu-item>
    </el-menu>
```

<el-menu>和</el-menu-item>

这里的实现：

> 本项目侧边栏主要基于 `element-ui` 的 `el-menu` 改造。
>
> 前面也介绍了，侧边栏是通过读取路	由并结合权限判断而动态生成的，而且还需要支持路由无限嵌套，所以这里还使用到了递归组件。

```vue
<template>
  <div :class="{'has-logo':showLogo}">
    <logo v-if="showLogo" :collapse="isCollapse" />
    <el-scrollbar wrap-class="scrollbar-wrapper">
      <el-menu
        :default-active="activeMenu"
        :collapse="isCollapse"
        :background-color="variables.menuBg"
        :text-color="variables.menuText"
        :unique-opened="false"
        :active-text-color="variables.menuActiveText"
        :collapse-transition="false"
        mode="vertical"
      >
        <sidebar-item v-for="route in permission_routes" :key="route.path" :item="route" :base-path="route.path" />
      </el-menu>
    </el-scrollbar>
  </div>
</template>
```

动态绑定item 和 path

### AppMain页面

appmain的显示内容组件在views文件夹下

通过在vue文件中编写template style 和 script 然后导出这个组件名，

但是具体的组件写在components中

# 图表组件

组件都写在components中，然后导出到views中

## chart组件

### 使用echarts

官网柱状图：

```js
import * as echarts from 'echarts';

var chartDom = document.getElementById('main');
var myChart = echarts.init(chartDom);
var option;

option = {
  legend: {},
  tooltip: {},
  dataset: {
    source: [
      ['product', '2012', '2013', '2014', '2015'],
      ['Matcha Latte', 41.1, 30.4, 65.1, 53.3],
      ['Milk Tea', 86.5, 92.1, 85.7, 83.1]
    ]
  },
  xAxis: [
    { type: 'category', gridIndex: 0 },
    { type: 'category', gridIndex: 1 }
  ],
  yAxis: [{ gridIndex: 0 }, { gridIndex: 1 }],
  grid: [{ bottom: '55%' }, { top: '55%' }],
  series: [
    // These series are in the first grid.
    { type: 'bar', seriesLayoutBy: 'row' },
    { type: 'bar', seriesLayoutBy: 'row' }
  ]
};

option && myChart.setOption(option);
```

1、引入ehcarts

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- 引入 ECharts 文件 -->
    <script src="echarts.min.js"></script>
</head>
</html>
```

2、准备一个具备高宽的 DOM 容器

```html
<body>
    <!-- 为 ECharts 准备一个具备大小（宽高）的 DOM -->
    <div id="main" style="width: 600px;height:400px;"></div>
</body>
```

3、设置配置信息

**init**

```js
var chartDom = document.getElementById('main');
var myChart = echarts.init(chartDom);
```

**指定配置项和数据**

```js
// 指定图表的配置项和数据
var option = {
    title: {
        text: '第一个 ECharts 实例'
    },
    tooltip: {},
    legend: {
        data:['销量']
    },
    xAxis: {
        data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
    },
    yAxis: {},
    series: [{
        name: '销量',
        type: 'bar',
        data: [5, 20, 36, 10, 10, 20]
    }]
};
```

**setOption**

```js
// 使用刚指定的配置项和数据显示图表。
myChart.setOption(option);
```

### 柱状图

需求就是每隔1分钟刷新一次表格，为了降低网络负载，于是用websocket

### **⚝未用websocket情况**

使用axios和定时器来解决

initChart来initwebcarts

drawData来使用axios获得后台数据，将option.series[0].data覆盖，最后setOption

```js
    // 初始化图表
    initChart () {
      // 基于准备好的dom，初始化echarts实例
      this.chart = echarts.init(this.$el, 'macarons')
      this.drawData()
    },
    // 获取后台数据
    drawData () {
      getCpuData().then(res => {
        let code = res["code"]
        if (code == 20000) {
          console.log(res)
          this.option.series[0].data = []        
          this.cpuData = res["cpu"]["pct"];
          // 赋值给图表data
          this.option.series[0].data.push({
            name: 'CPU占用率',
            value: Math.round(this.cpuData * 100)
          });
		//绘制图表数据
          this.chart.setOption(this.option, true)
        } else {
          alert("get failed")
        }
        console.log(this.cpuData)
      })
    },
```

生命周期mounted来初始化图表和设置定时器

```js
  mounted () {
    this.$nextTick(() => {
      this.initChart()
             // 设置定时器
      timer = setInterval(() => {
        this.drawData();
      }, 10000);
    })
  },
```

然后watch侦听器来监视option

```js
  watch: {
    // 观察cpu_option的变化
    option: {
      handler(newVal, oldVal) {
		//使用setOption更新数据
      },
      deep: true   //对象内部属性的监听
    },
  },
```

页面销毁时移除定时器，销毁echarts实例

```js
    // 页面销毁时移除定时器，销毁echarts实例
    beforeDestroy() {
      if (!chart) {
        return;
      }
      chart.dispose();
      clearInterval(timer);
    },
```

### **axios的基本使用**

```js
// 1、安装axios
npm install axios --save-dev
// 2、在main.js中引用axios
import axios from 'axios';
Vue.prototype.$axios = axios //全局注册，使用方法为:this.$axios
// 3、就可以在代码中使用axios发送请求了
this.$axios({
        url: '/vue-element-admin/article/list',
        method: 'get',
        params: query
    })
      .then(response => {
        console.log(response, "success");   // 成功的返回      
      })
      .catch(error => console.log(error, "error")); // 失败的返回
```

> 横坐标显示时间段，纵坐标显示人数，series为未戴的戴的
>
> 每隔1分钟向后台请求
>
> https://blog.csdn.net/qq_36256590/article/details/119611451
>
> 用到watch、定时器、清除上一次数据
>
> 可以说的坑：定时器清除
>
> https://evestorm.github.io/posts/55651/
>
> https://cloud.tencent.com/developer/article/1147082
>

优化

### **websocket**

使用websocket让后端给前端每隔1分钟传一次数据

在mounted钩子中先initCharts，进行echarts的init和setoption

然后this.init()，开启websocket

```vue
<template>
  <div class="demo-container">
    <div ref="chart_wrap" class="chart_wrap"></div>
  </div>
</template>
<script>
export default {
  name: "demo",
  computed: {},
  data() {
    return {
      path: "**************",
      ws: {},
      seriesData: [],
      wsData: {},
    };
  },
  created() {},
  mounted() {
    this.initCharts();
    this.init();
  },
  watch: {
    seriesData(data) {
      console.log(data);
      let a = data.map((x) => x.size);
      let b = data.map((x) => x.price);
      this.setOptions(a, b);
    },
  },
  methods: {
    initCharts() {
      this.chart = this.$echarts.init(this.$refs.chart_wrap);
      this.setOptions();
    },
    setOptions(a, b) {
      console.log(a);
      this.chart.setOption({
        title: {
          text: "trade",
        },
        tooltip: {},
        legend: {
          data: ["size","price"],
        },
        xAxis: {
          data: [],
        },
        yAxis: {},
        series: [
          {
            name:"size",
            data: a,
            type: "line",
            smooth: true,
          },
          {
            name:"price",
            data: b,
            type: "line",
            smooth: true,
          },
        ],
      });
    },
    init() {
        // 连接服务器
        var ws = new WebSocket("ws://127.0.0.1:8090")
        // 连接成功
        ws.onopen = function () {
            alert('连接成功')
        }
        ws.onerror = function () { alert("WebSocket连接发生错误") };

        // 接收到消息的回调方法
        ws.onmessage = function (msg) {
            console.log(
                msg.data
            );
            var data = JSON.parse(msg.data)
            option.series[0].data = data.message  //赋值
            myChart.setOption(option);  //设置
        }
    },
  },
};
</script>
<style  scoped>
.chart_wrap {
  height: 400px;
}
</style>
```

> websocket和http
>
> [前端和后台进行WebSocket长连接和axios轮询的方法（vue框架）](https://blog.csdn.net/weixin_43216105/article/details/89555480)
>
> [客户端及服务端的实现](https://blog.csdn.net/qq_33426324/article/details/104491306)
>
> 结合echarts
>
> https://blog.csdn.net/LoveMe_LoveMyDog/article/details/118248534
>
> 也可以在onmessage中setOption
>
> https://www.jianshu.com/p/6c35eb6f978a
>
> https://blog.csdn.net/weixin_43216105/article/details/89555480

### ⚝多路由下的websocket

**通过vuex来收集状态，在mutation中设置为initWebsocket的初始化函数，在vue根组件created周期中commit，子组件通过计算属性来更新值**

vuex+websocket

在App.vue中的created进行commit

```js
created() {
    //初始化websocket
    this.initSocket(this.itemId,null); 
},

    methods:{   
        //websocket初始化
        initSocket(itemId,userId){
            this.$store.commit('initWebsocket',itemId,userId)
        },
    },
```

在mutations.js中进行websocket的初始化

```js
const mutations= {
    //websocket初始化
    initWebsocket(state,itemId,userId){
        const wsUrl='websocket链接地址';
        const ws=new WebSocket(wsUrl);
        //建立连接
        ws.onopen=function () {
            //
        };
        //接收服务端消息
        ws.onmessage=function (e) {
            state.imMessages=JSON.parse(e.data);
            console.log('state中数据已更新');
            window.localStorage.setItem('imMsg',JSON.stringify(state.imMessages));
        };
        ws.close=function () {
            console.log('连接已断开');
        }
    },
};
export default mutations;
```

state.js文件：

```js
//存储数据
const state={
    //推送消息
    imMessages:{}
};
export default state;
```

getters.js

```js

const getter={
    //当前推送值
   getLocalData(state){
       if(state.imMessages){
           state.imMessage=JSON.parse(window.localStorage.getItem('imMsg'));
       }else{
           state.imMessage='';
       }
       return state.imMessage;
   }
    
};
export default getter;
```

子组件通过计算属性改变option.series[0].data

```js

       computed:{
            //获取推送消息内容
            option.series[0].data(){
    			if (this.$store.getters.getLocalData.type == 1) {
    				return this.$store.getters.getLocalData.chartsData;
    			}
                
            },
        },
```

### websocket实际的提升

**主要是通过谷歌浏览器的f12开发者工具来观察**

#### 总数据流量降低

http协议的头部太大，且每个请求携带的几百上千字节的头部大部分是重复的，而且http1.1版本不能复用头部，虽然其实我们的内容数据也不小，但是也是有开销的，websocket则因为复用长连接而没有这一问题。

#### 通信的实时性提高

websocket则允许我们在一条ws连接上同时并发多个请求，即在A请求发出后A响应还未到达，就可以继续发出B请求。由于TCP的慢启动特性（新连接速度上来是需要时间的），以及连接本身的握手损耗，都使得websocket协议的这一特性有很大的效率提升。**因为我们的数据量不是很大，这点不是很明显，如果数据量巨大的话，差异会大一些**

#### 服务器推送

传统方式是需要进行一个轮询，websocket支持服务器推送消息，这带来了及时消息通知的更好体验，也是ajax请求无法达到的。



### ⚝心跳机制实现

websocket心跳机制：顾名思义，就是**客户端每隔一段时间向服务端发送一个特有的心跳消息，每次服务端收到消息后只需将消息返回，此时，若二者还保持连接，则客户端就会收到消息，若没收到，则说明连接断开，此时，客户端就要主动重连，完成一个周期**
心跳的实现也很简单，**只需在第一次连接时用回调函数做延时处理，设置一个心跳超时时间，若某时间段内客户端发送了消息，而服务端未返回，则认定为断线。**

心跳实现完成后，在ws.onopen中调用即可;

**心跳状态在ws.onmessage中进行改变；**

**然后是重连部分，其实只需要新建一个延时回调，与心跳相似，只不过它是在连接失败时使用的，**

```js
    startHeartBeat (time) {
        setTimeout(() => {
            this.sendMsg({
                ModeCode: ModeCode.HEART_BEAT,
                msg: new Date()
            })
            this.waitingServer()
        }, time)
    }

    //延时等待服务端响应，通过webSocketState判断是否连线成功
    waitingServer () {
        this.webSocketState = false
        //onmessage中会将webSocketState置为true
        setTimeout(() => {
            if(this.webSocketState) {
                this.startHeartBeat(this.heartBeat.time)
                return
            }
            console.log('心跳无响应，已断线')
            try {
                this.close()
            } catch(e) {
                console.log('连接已关闭，无需关闭')
            }
            this.reconnectWebSocket()
        }, this.heartBeat.timeout)
    }

    //重连操作
    reconnectWebSocket () {
        if(!this.isReconnect) {
            return;
        }
        this.reconnectTimer = setTimeout(() => {
            eventBus.emitEvent('reconnect')
        }, this.heartBeat.reconnect)
    }
```



### 组件是否设置keep-alive

设置keep-alive

在AppMain.vue中设置

```vue
<template>
  <section class="app-main">
    <transition name="fade-transform" mode="out-in">
      <keep-alive :include="cachedViews">
        <router-view :key="key" />
      </keep-alive>
    </transition>
  </section>
</template>
```



## list组件

对违规的记录使用el-table进行展示，考虑到items量过大的情况，使用虚拟列表进行优化，加快渲染时间，减少浏览负担。

虚拟列表分两种做法，第一种是懒加载，第二种是可视区域渲染

### 懒加载

对于长列表渲染，传统的方法是使用懒加载的方式，下拉到底部获取新的内容加载进来，其实就相当于是在垂直方向上的分页叠加功能，**`但随着加载数据越来越多，浏览器的回流和重绘的开销将会越来越大`**，整个滑动也会造成卡顿，这个时候我们就可以考虑使用虚拟列表来解决问题

**实现思路**

监听父元素的 scroll 事件（一般是 window），通过父元素的 scrollTop 判断是否到了页面是否到了页面底部，如果到了页面底部，就加载更多的数据。

使用 Vue 实现了一个简单的例子，这个例子中的可滚动区域是在 window 上的，其中的核心代码只有三行：

```js
const maxScrollTop = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) - window.innerHeight;
const currentScrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop);

if (maxScrollTop - currentScrollTop < 20) {
  //...
}
```

**实现**

element table + vue基于插件实现：

因为element有针对列表的无限滚动组件，但是没有针对table的，所以需要自己实现

[基于el-table-infinite-scroll插件实现](https://blog.csdn.net/weixin_44019370/article/details/124600797)

https://github.com/yujinpan/el-table-infinite-scroll

懒加载相关

https://juejin.cn/post/7074865088309493791

https://zhuanlan.zhihu.com/p/26022258

### 可视区域渲染

其核心思想就是在处理用户滚动时，只改变列表在可视区域的渲染部分，

**虚拟列表相关**

[虚拟列表，我真的会了！！！](https://juejin.cn/post/7085941958228574215)

[「前端进阶」高性能渲染十万条数据(虚拟列表)](https://juejin.cn/post/6844903982742110216)

**table的实现**

和列表实现相差不大，注意的是和自己项目的案例中，这里数据应该是一次性请求完成，然后根据滚动事件改变data，以下是实现案例

[前端分享--虚拟列表在el-table中的实现](https://juejin.cn/post/7046666637050642446)

http://www.codebaoku.com/it-vue/it-vue-221377.html

https://cloud.tencent.com/developer/article/1836477



**使用的是element的el-table**

```vue
<template>
  <div class="app-container">
    <el-table v-loading="listLoading" :data="list" infinite-scroll-disabled="scrollDisabled" v-el-table-infinite-scroll="toLoadMore" infinite-scroll-immediate="false" border fit highlight-current-row style="width: 100%" >
      <el-table-column align="center" label="ID" width="80">
        <template slot-scope="scope">
          <span>{{ scope.row.id }}</span>
        </template>
      </el-table-column>

      <el-table-column width="180px" align="center" label="Date">
        <template slot-scope="scope">
          <span>{{ scope.row.timestamp | parseTime('{y}-{m}-{d} {h}:{i}') }}</span>
        </template>
      </el-table-column>

      <el-table-column width="120px" align="center" label="Author">
        <template slot-scope="scope">
          <span>{{ scope.row.author }}</span>
        </template>
      </el-table-column>

      <el-table-column width="100px" label="Importance">
        <template slot-scope="scope">
          <svg-icon v-for="n in +scope.row.importance" :key="n" icon-class="star" class="meta-item__icon" />
        </template>
      </el-table-column>

      <el-table-column class-name="status-col" label="Status" width="110">
        <template slot-scope="{row}">
          <el-tag :type="row.status | statusFilter">
            {{ row.status }}
          </el-tag>
        </template>
      </el-table-column>

      <el-table-column min-width="300px" label="Title">
        <template slot-scope="{row}">
          <router-link :to="'/example/edit/'+row.id" class="link-type">
            <span>{{ row.title }}</span>
          </router-link>
        </template>
      </el-table-column>

      <el-table-column align="center" label="Actions" width="120">
        <template slot-scope="scope">
          <router-link :to="'/example/edit/'+scope.row.id">
            <el-button type="primary" size="small" icon="el-icon-edit">
              Edit
            </el-button>
          </router-link>
        </template>
      </el-table-column>
    </el-table>

<!--    <pagination v-show="total>0" :total="total" :page.sync="listQuery.page" :limit.sync="listQuery.limit" @pagination="getList" />-->
  </div>
</template>

<script>
import { fetchList } from '@/api/article'
// import Pagination from '@/components/Pagination' // Secondary package based on el-pagination
import elTableInfiniteScroll from 'el-table-infinite-scroll'

export default {
  name: 'ArticleList',
  directives: {
    'el-table-infinite-scroll': elTableInfiniteScroll
  },
  // components: { Pagination },
  filters: {
    statusFilter(status) {
      const statusMap = {
        published: 'success',
        draft: 'info',
        deleted: 'danger'
      }
      return statusMap[status]
    }
  },
  data() {
    return {
      listLoading: false,
      scrollDisabled: false,
      list: [],
      listQuery: {
        page: 1,
        limit: 20
      }
    }
  },
  created() {
    // this.getList()
    this.toGetList()
  },
  methods: {
    toGetList() {
      this.listQuery.page = 1 // 初始化 搜索条件 页码
      this.scrollDisabled = true
      // this.list = [] // 搜索前清空滚动加载获取的数据，避免内容重复
      this.loadList(this.listQuery)
    },

    toLoadMore() {
      // 监听表格滚动事件
      this.listQuery.page++
      this.loadList(this.listQuery)
    },
    loadList(param) {
      this.listLoading = true
      fetchList(param).then(response => {
        this.listLoading = false
        // 没数据的时候，禁用 infinite-scroll-disabled 滚动事件
        if (response.data.length === 0) return (this.scrollDisabled = true)
        this.scrollDisabled = false
        this.list.push(...response.data.items)
      })

    }
  }
}
</script>

<style scoped>
.edit-input {
  padding-right: 100px;
}
.cancel-btn {
  position: absolute;
  right: 15px;
  top: 10px;
}
</style>

```

**使用了虚拟列表的技术**

elementUi对原生列表实现了**无限滚动**，用的是**懒加载的方式**

现在我们的需求是给elementUi中的table加上无限滚动，网上有**'el-table-infinite-scroll'**，

但是也是基于懒加载的方式实现的，缺点是**节点数变多页面负担增加**

### 'el-table-infinite-scroll'实现原理

v-el-table-infinite-scroll封装了滚动事件，当滚动到底部时，触发"toLoadMore" 事件，

```js
    toLoadMore() {
      // 监听表格滚动事件
      this.listQuery.page++
      this.loadList(this.listQuery)
    },
```

```js
    loadList(param) {
      this.listLoading = true
      fetchList(param).then(response => {
        this.listLoading = false
        // 没数据的时候，禁用 infinite-scroll-disabled 滚动事件
        if (response.data.length === 0) return (this.scrollDisabled = true)
        this.scrollDisabled = false
        this.list.push(...response.data.items)
      })

    }
```

### ⚝使用可视区域渲染来对el-table进行优化

**思路**

虚拟列表的实现，实际上就是在首屏加载的时候，**只加载可视区域内需要的列表项**，当滚动发生时，动态通过计算获得`可视区域`内的列表项，并将`非可视区域`内存在的列表项删除。



**设置父子容器，item在子容器中渲染，给子容器设置所有列表项的高度，形成滚动条；**

**设置滚动事件，根据scrollTop得到到容器顶部的距离，可计算出开始索引、结束索引和偏移量；**

**在计算属性中的visibleData发生变化，因为visibleData为this.listData.slice(this.start, Math.min(this.end,this.listData.length))那么可是区域就跟着变化；**

**因为设置了偏移量，通过样式控制将`渲染区域`偏移至`可视区域`中。**



**需要的数据**

**可视区域高度screenHeight** 为父容器的高度，固定

**列表项高度itemSize** 固定

**列表数据data** 一次性从后端请求

**当前滚动位置scrollTop **为滚动条到顶部的距离

可算出

**列表总高度`listHeight`** = listData.length * itemSize

**可显示的列表项数`visibleCount`** = Math.ceil(screenHeight / itemSize)

**数据的起始索引`startIndex`** = Math.floor(scrollTop / itemSize)

**数据的结束索引`endIndex`** = startIndex + visibleCount

**列表显示数据为`visibleData`** = listData.slice(startIndex,endIndex)

**偏移量startOffset** = scrollTop - (scrollTop % itemSize);

startOffset这样设置是因为

> 这个scrollTop - (scrollTop % this.itemSize)就是没达到一个itemSize的时候就是多余的减掉多余的变成0这个内容会被浏览器带着走 就会看到动画 如果你有设置等于scrollTop的话 你浏览器滚动了 那你偏移量和scrollTop一样的话 相当于没有动画 和浏览器同步走了 然后到了换数据item1变成item2的时候就会突然给你换掉 就没有动画了 这样写就让浏览器带着走有动画



**具体实现**

在data中定义可视区域高度screenHeight，偏移量startOffset，数据的起始索引`startIndex`，数据的结束索引`endIndex`，*每项高度*

```js
  data() {
    return {
      //可视区域高度
      screenHeight:0,
      //偏移量
      startOffset:0,
      //起始索引
      start:0,
      //结束索引
      end:null,
      itemSize： 200
    };
  },
```

在created钩子中 toGetList()将所有数据通过axios请求到listData，然后将数据截取为visibleData；

在computed中得到列表总高度`listHeight`，可显示的列表项数`visibleCount` ，*偏移量对应的style*，*真实显示列表数据*

```js
  computed:{
    //列表总高度
    listHeight(){
      return this.listData.length * this.itemSize;
    },
    //可显示的列表项数
    visibleCount(){
      return Math.ceil(this.screenHeight / this.itemSize)
    },
    //偏移量对应的style
    getTransform(){
      return `translate3d(0,${this.startOffset}px,0)`;
    },
    //获取真实显示列表数据
    visibleData(){
      return this.listData.slice(this.start, Math.min(this.end,this.listData.length));
    }
  },
```

在mounted钩子中计算可视区域高度screenHeight，起始索引，结束索引

```js
  mounted() {
    this.screenHeight = this.$el.clientHeight;
    this.start = 0;
    this.end = this.start + this.visibleCount;
  },
```

然后在methods定义滚动函数

```js
  methods: {
    scrollEvent() {
      //当前滚动位置
      let scrollTop = this.$refs.list.scrollTop;
      //此时的开始索引
      this.start = Math.floor(scrollTop / this.itemSize);
      //此时的结束索引
      this.end = this.start + this.visibleCount;
      //此时的偏移量
      this.startOffset = scrollTop - (scrollTop % this.itemSize);
    }
  }
```

template中父元素高度已设置，子元素的高度为列表总高度`listHeight`，撑开了盒子，然后用transform将渲染区域偏移至可视区域

1. 是created先执行。因为created是初始化data中的值。因此最先执行；
2. 然后是 执行computed中的，因为此时html正在被渲染，computed发生在 created 和 mounted 之间；
3. 最后是mounted()因为这个函数此时已经将页面渲染完成了。

### **基础上优化**

**下拉置地自动请求和加载数据**

在真实的开发场景中，我们不会一次性请求1w、10w条数据过来，这样请求时间那么长，用户早就把页面关掉了，还优化个屁啊哈哈！

所以真实开发中，我们还是要结合原来的懒加载方式，等到下拉触底的时候去加载新的数据进来，放置到缓存数据当中，然后我们再根据滚动事件决定具体渲染哪一部分的数据到页面上去。

```js
// 组件刚挂载以及下拉触底的时候请求更多数据
useEffect(() => {
  (async () => {
    try {
      // 表明当前正处于请求过程中
      isRequestRef.current = true
      const { offset } = options
      let limit = 20
      if (offset === 1) limit = 40
      const { data: { comments, more } } = await axios({
        url: `http://localhost:3000/comment/music?id=${186015 - offset}&limit=${limit}&offset=1`
      })
      isNeedLoad.current = more
      // 将新请求到的数据添加到存储列表数据的变量当中
      dataListRef.current = [...dataListRef.current, ...comments]
      // 必选要在boxScroll之前将isRequestRef设为false，因为boxScroll函数内部会用到这个变量
      isRequestRef.current = false
      // 请求完最新数据的时候需要重新触发一下boxScroll函数，因为容器内的数据、空白填充区域可能需要变化
      boxScroll()
    } catch (err) {
      isRequestRef.current = false
      console.log(err);
    }
  })()
  // 在boxScroll函数里面，一旦发生了触底操作就会去改变optiosn的值
}, [options])
```

**增大结束索引,增大缓冲区**

可以将结束索引设置的大一点，比如为

```
this.end = this.start + this.visibleCount * 2;
```

增大缓冲区



**滚动事件请求动画帧进行节流优化**

虚拟列表很依赖于滚动事件，考虑到用户可能会滑动很快，我们在用节流优化的时候事件必须要设置的够短，否则还是会出现白屏现象。

这里我没有用传统的节流函数，而是用到了请求动画帧帮助我们进行节流，这里我就不做具体介绍了，想了解的可以看我另一篇文章[juejin.cn/post/708236…](https://juejin.cn/post/7082366494348148744)[juejin.cn/post/684490…](https://juejin.cn/post/6844903982742110216#heading-3)

```js
// 利用请求动画帧做了一个节流优化
let then = useRef(0)
const boxScroll = () => {
  const now = Date.now()
  /**
   * 这里的等待时间不宜设置过长，不然会出现滑动到空白占位区域的情况
   * 因为间隔时间过长的话，太久没有触发滚动更新事件，下滑就会到padding-bottom的空白区域
   * 电脑屏幕的刷新频率一般是60HZ，渲染的间隔时间为16.6ms，我们的时间间隔最好小于两次渲染间隔16.6*2=33.2ms，一般情况下30ms左右，
   */
  if (now - then.current > 30) {
    then.current = now
    // 重复调用scrollHandle函数，让浏览器在下一次重绘之前执行函数，可以确保不会出现丢帧现象
    window.requestAnimationFrame(scrollHandle)
  }
}
```

**另一种方法：scroll节流**

```
export default function(fn, delay) {
    let lock = false;
    return (...args) => {
        if (lock)
            return;
        //进入加锁
        lock = true;
        setTimeout(() => {
            fn.apply(this, args);
            //执行完毕解锁
            lock = false;
        }, delay);
    }
}


```



### ⚝不定高虚拟列表实现

如果列表项是不定高的，那么结束索引和偏移量都不能用之前的计算方法。

可以**设置预估高度**

预估高度应该设置为**列表项产生的最小值**，这样尽管可能会多渲染出几条数据，但能保证首次呈现给用户的画面中没有空白。

**实现**

1、定义一个预估高度estimatedItemSize

2、定义一个positions数组，里面为对象，来存储每个列表项的index，top，bottom，height信息

```js
this.positions = [
  // {
  //   top:0,
  //   bottom:100,
  //   height:100
  // }
];
```

3、初始化时，用listData来初始化positions数组

```js
initPositions(){
  this.positions = this.listData.map((item,index)=>{
    return {
      index,
      height:this.estimatedItemSize,
      top:index * this.estimatedItemSize,
      bottom:(index + 1) * this.estimatedItemSize
    }
  })
}
```

4、计算出列表总高度为positions最后一项底部距离顶部的位置

```js
//列表总高度
listHeight(){
  return this.positions[this.positions.length - 1].bottom;
}
```

5、每次列表更新之后将列表项真实高度更新缓存中的预估高度

当下次我们再用到缓存中的这些数据时，使用的就是真实高度了

```js
updated(){
  let nodes = this.$refs.items;
  nodes.forEach((node)=>{
    let rect = node.getBoundingClientRect();
    let height = rect.height;
    let index = +node.id.slice(1)
    let oldHeight = this.positions[index].height;
    let dValue = oldHeight - height;
    //存在差值
    if(dValue){
      this.positions[index].bottom = this.positions[index].bottom - dValue;
      this.positions[index].height = height;
      for(let k = index + 1;k<this.positions.length; k++){
        this.positions[k].top = this.positions[k-1].bottom;
        this.positions[k].bottom = this.positions[k].bottom - dValue;
      }
    }
  })
}
```

6、滚动后获取列表`开始索引`的方法修改为通过`缓存`获取：

列表项的`bottom`属性代表的就是该元素尾部到容器顶部的距离，不难发现，可视区的第一个元素的`bottom`是第一个大于滚动高度的；可视区最后一个元素的`bottom`是第一个大于（滚动高度+可视高度）的。我们可以利用这条规则遍历缓存数组找到对应的`startIndex`和`endIndex`

由于我们的缓存数据，本身就是有顺序的，所以获取开始索引的方法可以考虑通过**二分查找**的方式来降低检索次数，减少时间复杂度

```js
//获取列表起始索引
getStartIndex(scrollTop = 0){
  //二分法查找
  return this.binarySearch(this.positions,scrollTop)
},
//二分法查找
binarySearch(list,value){
  let start = 0;
  let end = list.length - 1;
  let tempIndex = null;
  while(start <= end){
    let midIndex = parseInt((start + end)/2);
    let midValue = list[midIndex].bottom;
    if(midValue === value){
      return midIndex + 1;
    }else if(midValue < value){
      start = midIndex + 1;
    }else if(midValue > value){
      if(tempIndex === null || tempIndex > midIndex){
        tempIndex = midIndex;
      }
      end = end - 1;
    }
  }
  return tempIndex;
},
```

偏移量也可以获得

```js
scrollEvent() {
  //...省略
  if(this.start >= 1){
    this.startOffset = this.positions[this.start - 1].bottom
  }else{
    this.startOffset = 0;
  }
}
```

7、开始索引、结束索引、偏移量都能获得，那么就能够显示了。

#### 问题

但如果列表项中包含**图片**，并且列表高度由图片撑开。在这种场景下，由于图片会发送网络请求，列表项可能已经渲染到页面中了，但是图片还没有加载出来，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，获取到的高度有无包含图片高度，从而造成计算不准确的情况。

解决：

如果你真的遇到了这种列表项会由图片任意撑开的场景，可以给图片绑定`onload`事件，等到它加载完之后再重新计算一下列表的高度，然后把它更新到缓存数据中，这是一种方法。其次，还可以使用[ResizeObserver](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FResizeObserver)来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度，只不过MDN有说道这只是在实验中的一个功能，所以暂时可能没有办法兼容所有的浏览器！



### 最终问题

> 这种方式实现的问题比较多，主要就是在滚动时的卡顿。在单元格内容使用函数或者更复杂的渲染方式的时候，滚动流畅度还不如非虚拟化。本质原因是浏览器的滚动条在滚动的时候和js执行是互斥的，必须要模拟一个滚动条，然后再用js去调用滚动，这样就能保证在实际渲染前js已经执行好了，实际上只有渲染的事情了。

> 白屏的根本原因是浏览器触发混动事件的频率太快，你可能会说节流，没用的，你节的只是js执行频率，你阻止不了浏览器根据你的手势移动viewport，所以这是你白屏的原因，解决的根本办法就是自己模拟滚动，这样就可以限制滚动事件派发的速度

原理

> 大概是用transform先将容器的滚动条挤出可视区域，然后用自己实现的滚动条去渲染到原先的位置，同时监听鼠标滚轮事件(mousewheel)，根据滚轮的状态（1，-1）来计算滚动的位置，然后直接调用js的scrollTo去滚动到对应的位置。
> 这种方式配合实现方式为定位的虚拟列表效果比较好，可以将具体展示的表格内容定位到容器区域，根据scroll的位置计算应该显示的数据，然后重新计算定位位置即可，可以很大程度的去复用元素。
>
> 具体的可以参考这里[![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)segmentfault.com](https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000039808261)，然后自己去实现一下，并不是很难。表格还有很多其他功能，如何把它们整合到一起，怎么去设计好才是难点。



# 视频展示

https://juejin.cn/post/7091212799426166797

https://juejin.cn/post/7091588511526027271

https://blog.csdn.net/weixin_43643250/article/details/120215395



我们下载完开发包后会发现其中有一个nginx的文件夹，那很明显了，虽然不用后端在服务器用ffmpeg转换，但是还是要靠nginx用服务器转流。那海康是如何实现web直连的呢，通过官方的demo可以看到通过webSocket进行取流。这里需要注意的是要看海康的摄像头是否支持webSocket。



# 前端性能优化

## 首屏时间计算

`首屏时间`：也称**用户完全可交互时间**，即整个页面首屏完全渲染出来，用户完全可以交互，一般首屏时间小于页面完全加载时间，该指标值可以衡量页面访问速度

#### 1、首屏时间 VS 白屏时间

这两个完全不同的概念，**白屏时间是小于首屏时间的** `白屏时间`：首次渲染时间，指页面出现第一个文字或图像所花费的时间

#### 2、为什么 performance 直接拿不到首屏时间

随着 Vue 和 React 等前端框架盛行，`Performance` 已无法准确的监控到页面的首屏时间

因为 `DOMContentLoaded` 的值只能表示**空白页**（当前页面 body 标签里面没有内容）加载花费的时间

浏览器需要先加载 JS , 然后再通过 JS 来渲染页面内容，这个时候**单页面类型**首屏才算渲染完成

#### 常见计算方式

- 用户自定义打点—最准确的方式（只有用户自己最清楚，什么样的时间才算是首屏加载完成）
  - 缺点：侵入业务，成本高
- 粗略的计算首屏时间: `loadEventEnd - fetchStart/startTime` 或者 `domInteractive - fetchStart/startTime`（Performance API来计算）白屏时间: responseEnd - fetchStart
- 通过计算首屏区域内的所有图片加载时间，然后取其最大值
- 利用 [MutationObserver](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMutationObserver) 接口，监听 document 对象的节点变化

通过`window.performance.timing`来计算。

![](pics/首屏加载时间1.png)

![](pics/首屏加载时间2.png)

```
1. DNS解析耗时: domainLookupEnd - domainLookupStart
2. TCP连接耗时: connectEnd - connectStart
3. SSL安全连接耗时: connectEnd - secureConnectionStart
4. 网络请求耗时(TTFB): responseStart - requestStart
5. 数据传输耗时: responseEnd - responseStart
6. DOM解析耗时: domInteractive - responseEnd
7. 资源加载耗时: loadEventStart - domContentLoadedEventEnd
8. 首包时间: responseStart - domainLookupStart
9. 首次渲染时间 / 白屏时间: responseEnd - fetchStart
10. 首次可交互时间: domInteractive - fetchStart
11. DOM Ready时间: domContentLoadEventEnd - fetchStart
12. 页面完全加载时间: loadEventStart - fetchStart
```

这是 navigation timing 监测指标图，从图中我们可以看出，浏览器在得到用户请求之后，经历了下面这些阶段：重定向→拉取缓存→DNS 查询→建立 TCP 链接→发起请求→接收响应→处理 HTML 元素→元素加载完成。

## 性能指标

### Lighthouse性能指标

[首次内容绘制](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Ffcp%2F)（**First Contentful Paint**）。即浏览器首次将任意内容（如文字、图像、canvas 等）绘制到屏幕上的时间点。

[可交互时间](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Ftti%2F)（Time to Interactive）。指的是所有的页面内容都已经成功加载，且能够快速地对用户的操作做出反应的时间点。

[速度指标](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fspeed-index%2F)（**Speed Index**）。衡量了首屏可见内容绘制在屏幕上的速度。在首次加载页面的过程中尽量展现更多的内容，往往能给用户带来更好的体验，所以速度指标的值约小越好。

[总阻塞时间](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Ftbt%2F)（Total Blocking Time）。指First Contentful Paint 首次内容绘制 (FCP)与Time to Interactive 可交互时间 (TTI)之间的总时间

[最大内容绘制](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Flcp%2F)（**Largest Contentful Paint**）。度量标准报告视口内可见的最大图像或文本块的呈现时间

[累积布局偏移](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Fcls%2F)（Cumulative Layout Shift）。衡量的是页面整个生命周期中每次元素发生的非预期布局偏移得分的总和。每次可视元素在两次渲染帧中的起始位置不同时，就说是发生了LS（Layout Shift）。

### 首屏性能指标

**FP、FCP、FMP+CWV（Core Web Vitals）**

FP（**First Paint** 译为“**首次绘制**”）代表浏览器第一次向屏幕传输像素的时间，仅表示当前已经开始绘制了，实际意义比较小。也就是**白屏**的概念

FCP（**First Contentful Paint** 译为“**首次内容绘制**”）代表浏览器第一次向屏幕绘制 “**内容**”（只有首次绘制文本、图片（包含背景图）、非白色）。也就是**首屏**的概念。

相比之下，FCP 指的是浏览器**首次绘制来自 DOM 的内容**。例如：文本，图片，SVG，canvas元素等，这个时间点叫 FCP。

FMP（**First Meaningful Paint** 译为“**首次有效绘制**”）表示页面中**有意义的内容**开始出现在屏幕上的时间点。它也是我们来衡量用户加载体验的主要指标。

FMP 本质上是一个主观认知指标，是通过一个算法来猜测某个时间点可能是 FMP，但是计算方式过于复杂而且不准确，后来 Google 也放弃了 FMP 的探测算法，转而采用更加明确的客观指标 - LCP。

### Web核心指标CWV

目前的 **Web 核心指标**由三个方面构成 — 页面加载性能、交互性、视觉稳定性，包含如下三个指标及阈值：

Largest Contentful Paint (LCP)：**最大内容绘制**，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的2.5 秒内发生。

First Input Delay (FID)：**首次输入延迟**，测量交互性。是指用户**首次和网站进行交互到浏览器响应该事件的实际延时时间**

Cumulative Layout Shift (CLS)：CLS 是用来衡量视觉界面稳定性的一个指标，指的是**页面产生的连续累计布局偏移分数**。

### 页面流畅度指标

**FPS**

**帧率** FPS（Frames Per Second - 每秒传输帧数），一般对于网页而言，最优的帧率在 60 FPS，如果越接近这个值，页面就越流畅，帧率如果远低于这个值，用户可能会明显感觉到卡顿。

60 FPS 意味着页面每隔 16.5ms（1/60）就需要渲染一次，否则就会出现丢帧的现象，而浏览器中的 JavaScript 执行和页面渲染都是会相互阻塞的，如果在代码中有非常复杂的逻辑占用了大量的执行时长，就会导致页面出现卡顿。

**requestAnimationFrame**

window.requestAnimationFrame() 告诉浏览器你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。

这里借用 MDN 的描述，顾名思义就是传入一个函数，让浏览器在下一次渲染之前进行调用。那么基于这个特性，结合上面提供的 FPS 计算示例代码，我们可以发现，如果我们持续对 requestAnimationFrame 进行调用，那么每次调用的间隔应该在 16.7ms 左右，即满足我们对于页面流畅度 60 FPS 的要求，

### 网络指标

三个时间指标

- Total Connection Time：整体的连接耗时
- TTFB（Time to First Byte）：首字节传输耗时
- Content Download：内容传输耗时

### Performance指标值

| 名词                           | 解析           | 详细                                                         |
| ------------------------------ | -------------- | ------------------------------------------------------------ |
| FP (First Paint)               | 首次绘制       | 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点 |
| FCP (First Contentful Paint)   | 首次内容绘制   | 标记浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、非空白canvas或SVG 甚至 元素. |
| LCP (Largest Contentful Paint) | 最大内容渲染   | 代表在viewport中最大的页面元素加载的时间. LCP的数据会通过PerformanceEntry对象记录, 每次出现更大的内容渲染, 则会产生一个新的PerformanceEntry对象. |
| DCL (Dom Content loaded)       |                | 当 HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的完成加载 |
| FMP(First Meaningful Paint)    | 首次有效绘制   |                                                              |
| L (onLoad)                     | 加载完成       | 当依赖的资源, 全部加载完毕之后才会触发.                      |
| TTI (Time to Interactive)      | 可交互时间     | 指标用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点.  |
| TBT (Total Blocking Time)      | 页面阻塞总时长 | TBT汇总所有加载过程中阻塞用户操作的时长，在FCP和TTI之间任何long task中阻塞部分都会被汇总 |
| FID (First Input Delay)        | 首次输入延迟   | 指标衡量的是从用户首次与您的网站进行交互（即当他们单击链接，点击按钮等）到浏览器实际能够访问之间的时间 |
| CLS (Cumulative Layout Shift)  | 累积布局偏     | 总结起来就是一个元素初始时和其hidden之间的任何时间如果元素偏移了, 则会被计算进去。具体的计算方法可看这篇文章 [《Cumulative Layout Shift (CLS)》](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fcls%2F) |
| SI (Speed Index)               |                | 指标用于显示页面可见部分的显示速度, 单位是时间               |

![](pics/首屏加载时间1.png)

```
1. DNS解析耗时: domainLookupEnd - domainLookupStart
2. TCP连接耗时: connectEnd - connectStart
3. SSL安全连接耗时: connectEnd - secureConnectionStart
4. 网络请求耗时(TTFB): responseStart - requestStart
5. 数据传输耗时: responseEnd - responseStart
6. DOM解析耗时: domInteractive - responseEnd
7. 资源加载耗时: loadEventStart - domContentLoadedEventEnd
8. 首包时间: responseStart - domainLookupStart
9. 首次渲染时间 / 白屏时间: responseEnd - fetchStart
10. 首次可交互时间: domInteractive - fetchStart
11. DOM Ready时间: domContentLoadEventEnd - fetchStart
12. 页面完全加载时间: loadEventStart - fetchStart
```

这是 navigation timing 监测指标图，从图中我们可以看出，浏览器在得到用户请求之后，经历了下面这些阶段：重定向→拉取缓存→DNS 查询→建立 TCP 链接→发起请求→接收响应→处理 HTML 元素→元素加载完成。

## 性能测试工具

### Lighthouse

谷歌官方提供的性能检测工具Lighthouse，它可以搜集多个现代网页性能指标，分析 Web 应用的性能并生成报告，为开发人员进行性能优化的提供了参考方向。

#### 性能指标

[首次内容绘制](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Ffcp%2F)（**First Contentful Paint**）。即浏览器首次将任意内容（如文字、图像、canvas 等）绘制到屏幕上的时间点。

[可交互时间](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Ftti%2F)（Time to Interactive）。指的是所有的页面内容都已经成功加载，且能够快速地对用户的操作做出反应的时间点。

[速度指标](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fspeed-index%2F)（**Speed Index**）。衡量了首屏可见内容绘制在屏幕上的速度。在首次加载页面的过程中尽量展现更多的内容，往往能给用户带来更好的体验，所以速度指标的值约小越好。

[总阻塞时间](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Ftbt%2F)（Total Blocking Time）。指First Contentful Paint 首次内容绘制 (FCP)与Time to Interactive 可交互时间 (TTI)之间的总时间

[最大内容绘制](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Flcp%2F)（**Largest Contentful Paint**）。度量标准报告视口内可见的最大图像或文本块的呈现时间

[累积布局偏移](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fi18n%2Fzh%2Fcls%2F)（Cumulative Layout Shift）。衡量的是页面整个生命周期中每次元素发生的非预期布局偏移得分的总和。每次可视元素在两次渲染帧中的起始位置不同时，就说是发生了LS（Layout Shift）。

#### 三个方面

这六个指标中，`LCP、 FCP、speed index`、 这三个指数尤为重要，因为在一般情况下 这个三个指标会影响 `TTI、TBT、CLS` 的分数，所以思路是优化`LCP、 FCP、speed index`



### Performance

lighthouse生成一个报告有些参数来源于performance，相对比lighthouse的分数和建议，performance用于记录和分析我们的应用在运行时的所有活动。它呈现的数据具有实时性、多维度的特点，可以帮助我们很好地定位性能问题。

Performance整体分析

![WechatIMG57.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60a3c21d41b44015808a7038608634c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

### **webpack-bundle-analyzer**

## ⚝优化思路

从**网络层面**和**渲染层面**两个大方向进行着手。

### 网络层面

**网络层面**的性能优化，无疑是如何让**资源体积更小加载更快**，

网络层面的思路，可以分为**开发阶段**和**生产阶段**来着手。

#### 开发阶段

**构建策略**：基于构建工具`webpack`做相关处理，配置合适的搜索范围、缓存副本、定向搜索、选择配置并行构建、使用**BundleAnalyzer**分析体积，**优化分包**，摇树优化，压缩资源； webpack之外的方面 **懒加载、按需引入**等。

**图像策略**：选择合适的图像类型(`JPG/PNG/SVG/WebP/Base64`)，webp格式图片，精灵图，iconfont，svg图标，图片懒加载，CSS代替图片



#### 生产阶段

**分发策略**：基于内容分发网络(`CDN`)，基于`CDN`的**就近原则**所带来的优点，可将网站所有静态资源全部部署到`CDN服务器`里。

**网络策略**：DNS解析优化，升级HTTP2

**缓存策略**：基于浏览器缓存(强缓存和协商缓存)

**服务端策略**： 开启GZIP、服务端渲染



### 渲染层面

**渲染层面**的性能优化，无疑是如何让代码**解析更好执行更快**。

**Preconnect、Prefetch、Preload**

**预渲染Prerender**

**CSS策略**：基于CSS规则

**DOM策略**：基于DOM操作

**阻塞策略**：基于脚本加载

**回流重绘策略**：基于回流重绘

**异步更新策略**：基于异步更新



## 构建策略

该策略主要围绕`webpack`做相关处理，同时也是接入最普遍的`性能优化策略`。其他构建工具的处理也是大同小异，可能只是配置上不一致。说到`webpack`的`性能优化`，无疑是从`时间层面`和`体积层面`入手。

- **减少打包时间**：`缩减范围`、`缓存副本`、`定向搜索`、`提前构建`、`并行构建`、`可视结构`
- **减少打包体积**：`分割代码`、`摇树优化`、`动态垫片`、`按需加载`、`作用提升`、`压缩资源`

## 缩减范围

**配置include/exclude缩小Loader对文件的搜索范围**，好处是`避免不必要的转译`。

`include/exclude`通常在各大`Loader`里配置，`src目录`通常作为源码目录，可做如下处理。当然`include/exclude`可根据实际情况修改。

```js
export default {
    // ...
    module: {
        rules: [{
            exclude: /node_modules/,
            include: /src/,
            test: /\.js$/,
            use: "babel-loader"
        }]
    }
};
```

## 缓存副本

**配置cache缓存Loader对文件的编译副本**，好处是`再次编译时只编译修改过的文件`。

大部分Loader/Plugin都会提供一个可使用编译缓存的选项，**通常包含cache字眼**。以babel-loader和eslint-webpack-plugin为例。

```js
import EslintPlugin from "eslint-webpack-plugin";

export default {
    // ...
    module: {
        rules: [{
            // ...
            test: /\.js$/,
            use: [{
                loader: "babel-loader",
                options: { cacheDirectory: true }
            }]
        }]
    },
    plugins: [
        new EslintPlugin({ cache: true })
    ]
};
```

## 定向搜索

**配置resolve提高文件的搜索速度**，好处是`定向指定必须文件路径`。若某些第三方库以常规形式引入可能报错或希望程序自动索引特定类型文件都可通过该方式解决。

`alias`映射模块路径，`extensions`表明文件后缀，`noParse`过滤无依赖文件。通常配置`alias`和`extensions`就足够。

```js
export default {
    // ...
    resolve: {
        alias: {
            "#": AbsPath(""), // 根目录快捷方式
            "@": AbsPath("src"), // src目录快捷方式
            swiper: "swiper/js/swiper.min.js"
        }, // 模块导入快捷方式
        extensions: [".js", ".ts", ".jsx", ".tsx", ".json", ".vue"] // import路径时文件可省略后缀名
    }
};
```

## 并行构建

**配置Thread将Loader单进程转换为多进程**，好处是`释放CPU多核并发的优势`。在使用`webpack`构建项目时会有大量文件需解析和处理，构建过程是计算密集型的操作，随着文件增多会使构建过程变得越慢。

在此需注意一个问题，若项目文件不算多就不要使用该`性能优化建议`，毕竟开启多个线程也会存在性能开销。

```js
import Os from "os";

export default {
    // ...
    module: {
        rules: [{
            // ...
            test: /\.js$/,
            use: [{
                loader: "thread-loader",
                options: { workers: Os.cpus().length }
            }, {
                loader: "babel-loader",
                options: { cacheDirectory: true }
            }]
        }]
    }
};
```

## **webpack-bundle-analyzer**

通过这个插件，立马知道echarts和element是全局引入的

**新版vuecli直接内置不用安装**

**最新指令**

```
npm run build -- --report
```

\1. 首先安装webpack的可视化资源分析工具，命令行执行：

```css
npm i webpack-bundle-analyzer -D
```

\2. 然后在webpack的dev开发模式配置中，引入插件，代码如下：

```javascript
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer')

plugins: [
    new BundleAnalyzerPlugin()
]
```

\3. 最后命令行执行`npm run build --report` , 浏览器会自动打开分析结果，如下所示：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/10/1729bf9a6a2182d3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom: 50%;" />

## ⚝分割代码/优化分包splitChunks

**分割各个模块代码，提取相同部分代码定义公共模块**，好处是**减少重复代码的出现频率**。`webpack v4`使用`splitChunks`替代`CommonsChunksPlugin`实现代码分割。

其原因是基于浏览器会缓存你的代码这一事实。每当你对某一文件做点改变，访问你站点的人们就要重新下载它。然而依赖却很少变动。如果你将（这些依赖）分离成单独的文件，访问者就无需多次重复下载它们了。

找到相关配置如下：

```yaml
export default {
    // ...
    optimization: {
        runtimeChunk: { name: "manifest" }, // 抽离WebpackRuntime函数
        splitChunks: {
            cacheGroups: {
                common: {
                    minChunks: 2,
                    name: "common",
                    priority: 5,
                    reuseExistingChunk: true, // 重用已存在代码块
                    test: AbsPath("src")
                },
                vendor: {
                    chunks: "initial", // 代码分割类型
                    name: "vendor", // 代码块名称
                    priority: 10, // 优先级
                    test: /node_modules/ // 校验文件正则表达式
                }
            }, // 缓存组
            chunks: "all" // 代码分割类型：all全部模块，async异步模块，initial入口模块
        } // 代码块分割
    }
};
```

**cacheGroups**字面意思缓存组，其实就是**定义分包规则，满足条件就将这些依赖提取到一个模块中**，是splitChunks的关键配置。webpack就是通过这里判断如何拆分模块的。

**⚝常用属性：**

- chunks：chunks有**三个选项**：`initial`、`async`和`all`。它指示应该优先分离同步（initial）、异步（async）还是所有的代码模块。这里的异步指的是通过动态加载方式（`import()`）加载的模块。
- minSize：表示抽取出来的文件在**压缩前的最小大小**，默认为 30KB；
- maxInitialRequests：**最大的初始化加载数**，默认为 3；这两个参数表示如果即将分离的 chunk 文件体积小于 30KB 的话，那么就不会将该 chunk 分离出来；并且限制并行下载的 chunk 最大请求个数为 3 个。`import()` 异步加载不算在内
- maxAsyncRequests：异步请求中的最大并发请求数。`import()` 本身算一个请求
- cacheGroups:**缓存组。它允许自定义规则分离 chunk**。并且每条`cacheGroups`规则下都允许定义上面提到的`chunks`和`minSize`字段用于覆盖全局配置
- minChunks：**表示被引用次数**，默认为1；上述配置commons中minChunks为2，表示将被多次引用的代码抽离成commons。
- priority：优先级
- reuseExistingChunk: 该选项只会出现在`cacheGroups`的分离规则中，意味重复利用现有的 chunk。



**模块太多太少都不好，不能那么极端。集中在一起能减少请求数量，分开能加快下载速度，但同时，前者增加了下载时间，后者增加了连接建立释放所花费的时间。这其中的利弊还需根据具体情况来衡量。**

一般情况下，越早使用的模块越先加载。该项目中我将依赖分为：

1. vue全家桶
2. UI组件
3. 其他依赖

配置如下：

```php
/**
 * vue.config.js
 */
configureWebpack: config => {
    Object.assign(config.optimization.splitChunks.cacheGroups, {
      'view-design': { // 分离组件库
        name: true, // name 为true会自动命名
        test: /[\\/]view-design[\\/]/,
        priority: 10,
        chunks: 'initial'
      },
      vue: { // 分离vue全家桶
        name: true,
        test: /[\\/]vue(.+?)[\\/]/,
        priority: 5,
        chunks: 'initial'
      }
    })
  }
}
```



## 摇树优化

**删除项目中未被引用代码**，好处是`移除重复代码和未使用代码`。`摇树优化`首次出现于`rollup`，是`rollup`的核心概念，后来在`webpack v2`里借鉴过来使用。

**摇树优化只对ESM规范生效，对其他模块规范失效。摇树优化针对静态结构分析，只有import/export才能提供静态的导入/导出功能。因此在编写业务代码时必须使用ESM规范才能让摇树优化移除重复代码和未使用代码。**

在`webpack`里只需将打包环境**设置成生产环境就能让摇树优化生效**，**同时业务代码使用ESM规范编写**，使用`import`导入模块，使用`export`导出模块。

```js
export default {
    // ...
    mode: "production"
};
```

**也可以在项目的`package.json`文件中，添加`"sideEffects"`属性**

```text
{
  "name": "your-project",
  "sideEffects": ["*.css","*.less"] // 其他有副作用的文档类型可以追加
}
```

## 压缩资源

**压缩HTML/CSS/JS代码，压缩字体/图像/音频/视频**，好处是`更有效减少打包体积`。极致地优化代码都有可能不及优化一个资源文件的体积更有效。

针对`HTML`代码，使用**html-webpack-plugin**开启压缩功能。

针对`CSS/JS`代码，分别使用以下插件开启压缩功能。其中`OptimizeCss`基于`cssnano`封装，`Uglifyjs`和`Terser`都是`webpack`官方插件，同时需注意压缩`JS代码`需区分`ES5`和`ES6`。

- [optimize-css-assets-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FNMFR%2Foptimize-css-assets-webpack-plugin)：压缩`CSS代码`
- [uglifyjs-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fuglifyjs-webpack-plugin)：压缩`ES5`版本的`JS代码`
- [terser-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fterser-webpack-plugin)：压缩`ES6`版本的`JS代码`

针对`字体/音频/视频`文件，还真没相关`Plugin`供我们使用，就只能拜托大家在发布项目到生产服前使用对应的压缩工具处理了。



## 懒加载

**将路由页面/触发性功能单独打包为一个文件，使用时才加载**，好处是`减轻首屏渲染的负担`。因为项目功能越多其打包体积越大，导致首屏渲染速度越慢。

首屏渲染时只需对应`JS代码`而无需其他`JS代码`，所以可使用`按需加载`。`webpack v4`提供模块按需切割加载功能，配合`import()`可做到首屏渲染减包的效果，从而加快首屏渲染速度。只有当触发某些功能时才会加载当前功能的`JS代码`。

`webpack v4`提供魔术注解命名`切割模块`，若无注解则切割出来的模块无法分辨出属于哪个业务模块，所以一般都是一个业务模块共用一个`切割模块`的注解名称。

```js
const Login = () => import( /* webpackChunkName: "login" */ "../../views/login");
const Logon = () => import( /* webpackChunkName: "logon" */ "../../views/logon");
```

#### 路由懒加载

##### 路由懒加载所做的事情

 \1. 将路由对应的组件加载成一个个对应的js包 。
  \2. 在路由被访问时才将对应的组件加载。  

##### 如何使用路由懒加载呢

```go
    routes: [   //未使用                  routes:[   //使用
    {                                       {
      path: '/imgDetail',                    path:'/imgDeatail',
      name: 'imgDetail',                     name::'imgDetail',
      component: imgDetail                   component:()=>import('../components/imgDetail')
    },                                     },
  ]                                       ]
 
 或者依然使用第一种路由的声明方式，但是在函数外部引用：
   const imgDetail = ()=> import('./components/imgDetail')
```

懒加载前提的实现：ES6的动态地加载模块——import()函数。import会返回一个Promise对象。

`component` (和 `components`) 配置接收一个**返回 Promise 组件的函数**，Vue Router **只会在第一次进入页面时才会获取这个函数**，然后使用缓存数据。

#### 组件懒加载

```js
1.  异步方法
<template>
  <div class="hello">
  <One-com></One-com>
  1111
  </div>
</template>

<script>
export default {
  components:{
    "One-com":resolve=>(['./one'],resolve)
  },
  data () {
    return {
      msg: 'Welcome to Your Vue.js App'
    }
  }
}
</script>

2.  ES6的const方法
<template>
  <div class="hello">
  <One-com></One-com>
  1111
  </div>
</template>

<script>
const One = ()=>import("./one");
export default {
  components:{
    "One-com":One
  },
  data () {
    return {
      msg: 'Welcome to Your Vue.js App'
    }
  }
}
</script>
```

#### 图片懒加载

**原理**

先将img标签的src链接设为同一张图片(默认图片)，当js监听到该图片进入可视窗口时，再将实际地址应用。

**判断进入视口viewport**

图片距离顶部距离 < 视窗高度 + 页面滚动高度（太LOW了~）

```javascript
imgEle.offsetTop < window.innerHeight + document.body.scrollTop
```

**对图片实现懒加载**

```scss
  /**
   * 对图片进行懒加载
   */
  function lazyLoad(img, src){
    if(img && src && isVisible(img)){ // 元素存在，元素未被加载，元素可见
      setTimeout(function(){
        img.setAttribute('src', src)
      }, 1000) // 模拟网络请求
    }
  }
```

**添加滚动监听**

```javascript
  // 窗口滚动
  window.addEventListener('scroll', function(){
    lazyLoad(img, src)
  })
```



## 按需引入

#### element-ui按需引入

如果是**全局引入**，如下:

```js
import Vue from 'vue';
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';
import App from './App.vue';

Vue.use(ElementUI);

new Vue({
  el: '#app',
  render: h => h(App)
});
```

import然后use注册

**按需引入**

1、按照文档上的按需引入需要先安装 babel-plugin-component：

```
npm install babel-plugin-component -D
```

2、在babel.config.js中修改

```js
{
  "presets": [["es2015", { "modules": false }]],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ]
  ]
}
```

3、接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容：

```javascript
import Vue from 'vue';
import { Button, Select } from 'element-ui';
import App from './App.vue';

 Vue.use(Button)
 Vue.use(Select)

new Vue({
  el: '#app',
  render: h => h(App)
});
```

import＋use

按需引入的时候，并不是按照你使用的组件去按需引入，而是看你用了多少它的标签，每一个使用的标签都需要去引入，不然没办法解析。

那这里你用到的每一个标签，你都要去引入。 `<el-row> <el-col> <el-dropdown> `

`<el-dropdown-menu> <el-dropdown-item>` 都需要去引入，在按需引入的官方文档上都能找的到这些标签：

```php
import { 
    Row,
    Col,
    Dropdown,
    DropdownMenu,
    DropdownItem
    } from 'element-ui';
Vue.use(Row).use(Col).use(Dropdown).use(DropdownMenu).use(DropdownItem);
```

要注意，部分标签的引入方式不是通过 `use` 而是直接在 `Vue` 的原型上绑定，比如说 `Message` :

```ini
Vue.prototype.$message = Message
```



#### ECarts按需引入

```js
// 引入 echarts 核心模块，核心模块提供了 echarts 使用必须要的接口。
import * as echarts from 'echarts/core';
// 引入柱状图图表，图表后缀都为 Chart
import { BarChart } from 'echarts/charts';
// 引入提示框，标题，直角坐标系，数据集，内置数据转换器组件，组件后缀都为 Component
import {
  TitleComponent,
  TooltipComponent,
  GridComponent,
  DatasetComponent,
  TransformComponent
} from 'echarts/components';
// 标签自动布局，全局过渡动画等特性
import { LabelLayout, UniversalTransition } from 'echarts/features';
// 引入 Canvas 渲染器，注意引入 CanvasRenderer 或者 SVGRenderer 是必须的一步
import { CanvasRenderer } from 'echarts/renderers';

// 注册必须的组件
echarts.use([
  TitleComponent,
  TooltipComponent,
  GridComponent,
  DatasetComponent,
  TransformComponent,
  BarChart,
  LabelLayout,
  UniversalTransition,
  CanvasRenderer
]);

// 接下来的使用就跟之前一样，初始化图表，设置配置项
var myChart = echarts.init(document.getElementById('main'));
myChart.setOption({
  // ...
});
```

> 需要注意的是为了保证打包的体积是最小的，ECharts 按需引入的时候不再提供任何渲染器，所以需要选择引入 `CanvasRenderer` 或者 `SVGRenderer` 作为渲染器。这样的好处是假如你只需要使用 svg 渲染模式，打包的结果中就不会再包含无需使用的 `CanvasRenderer` 模块。





## 图像

### 图像选择

`图像选型`一定要知道每种图像类型的`体积/质量/兼容/请求/压缩/透明/场景`等参数相对值，这样才能迅速做出判断在何种场景使用何种类型的图像。

| 类型   | 体积   | 质量 | 兼容 | 请求 | 压缩 | 透明   | 场景                       |
| ------ | ------ | ---- | ---- | ---- | ---- | ------ | -------------------------- |
| JPG    | 小     | 中   | 高   | 是   | 有损 | 不支持 | 背景图、轮播图、色彩丰富图 |
| PNG    | 大     | 高   | 高   | 是   | 无损 | 支持   | 图标、透明图               |
| SVG    | 小     | 高   | 高   | 是   | 无损 | 支持   | 图标、**矢量图**           |
| WebP   | 小     | 中   | 低   | 是   | 兼备 | 支持   | 看兼容情况                 |
| Base64 | 看情况 | 中   | 高   | 否   | 无损 | 支持   | 图标                       |
| GIF    |        |      |      |      | 无损 | 支持   | 多帧动画，动图             |

### 使用HTTP2

下面大栏

### 使用缓存

### 使用webP图片

- 自动化生成，可以使用image-min-webp或其他webpack插件

- HTML中使用，`<picture>`标签兼容

```bash
<picture>
    <source srcset="hehe.webp" type="image/webp">
    <img src="hehe.png" alt="hehe>
</picture>
```

- CSS中使用，需要配合JS做判断

```javascript
// main.js
window.addEventListener('DOMContentLoaded', () => {
    const isSupportWebP = document.createElement('canvas')
    .toDataURL('image/webp')
    .indexOf('data:image/webp') === 0
    document.documentElement.classList.add(isSupportWebP ? '' : '.no-support-webp');
})
// css
.support-webp .bg{
    background-image: url("hehe.webp");
}

.no-support-webp .bg {
    background-image: url("hehe.png");
}
```

### 构建时压缩图片

每次使用在线服务手动压缩较为麻烦，可以直接在构建流程中加入压缩图片

##### 使用**image-webpack-loader**

```javascript
// install
npm i image-webpack-loader -D
// vue.config.js
chainWebpack: (config) => {
    if (isProd) {
        // 图片压缩处理
        const imgRule = config.module.rule('images')
        imgRule
            .test(/\.(png|jpe?g|gif|webp)(\?.*)?$/)
            .use('image-webpack-loader')
            .loader('image-webpack-loader')
            .options({ bypassOnDebug: true })
            .end()
    }
}
```

### 使用雪碧图

浏览器请求资源的时候，同源域名请求资源的时候有**最大并发限制，chrome 为 6 个**，就比如你的页面上有 10 个相同 CDN 域名小图片，那么需要发起 10 次请求去拉取，分两次并发。第一次并发请求回来后，发起第二次并发。如果你把 10 个小图片合并为一张大图片的画，那么只用一次请求即可拉取下来 10 个小图片的资源。减少服务器压力，减少并发，减少请求次数。

**优点**

把诸多小图片合成一张大图，利用 `backround-position` 属性值来确定图片呈现的位置，可以有效的较少请求个数，而且，而不影响开发体验，使用构建插件可以做到对开发者透明。适用于页面图片多且丰富的场景。

**缺点**

生成的图片体积较大，减少请求个数同时也增加了图片大小，不合理拆分将不利于并行加载。

**合成雪碧图**

在 webpack 中，有相应的插件提供了自动合成雪碧图的功能并且可以自动生成对应的样式文件—— webpack-spritesmith，使用方法如下

```js
var path = require('path')
var SpritesmithPlugin = require('webpack-spritesmith')

module.exports = {
  // ...
  plugins: [
    new SpritesmithPlugin({
      src: {
        cwd: path.resolve(__dirname, 'src/ico'),
        glob: '*.png',
      },
      target: {
        image: path.resolve(__dirname, 'src/spritesmith-generated/sprite.png'),
        css: path.resolve(__dirname, 'src/spritesmith-generated/sprite.styl'),
      },
      apiOptions: {
        cssImageRef: '~sprite.png',
      },
    }),
  ],
}
```

### 使用 iconfont

iconfont(字体图标)，即通过字体的方式展示图标，多用于渲染图标、简单图形、特殊字体等。

**优点**

- **矢量图形**，设置大小、颜色及其他样式，**不失真**
- 灵活，高维护性，设计者无需针对不同场景切换图片，通过class即可完成修改，只需要维护一个图标项目库即可。
- **有效减少 HTTP 请求次数**
- **节约流量**，图标是图片格式，每个几K到几十K，而css文件一般一共只有几K。

##### IconFont 原理

IconFont 的使用原理来自于 css 的 `@font-face` 属性。这个属性用来定义一个新的字体，基本用法如下

```css
@font-face {
  font-family: <YourFontName>;
  src: <url> [<format>],[<source> [<format>]], *;
  [font-weight: <weight>];
  [font-style: <style>];
}
```

**font-family**：为载入的字体取名字。

**src**：[url]加载字体，可以是相对路径，可以是绝对路径，也可以是网络地址。[format]定义的字体的格式，用来帮助浏览器识别。主要取值为：【truetype(.ttf)、opentype（.otf）、truetype-aat、embedded-opentype(.eot)、svg(.svg)、woff(.woff)】。

**font-weight**：定义加粗样式。

**font-style**：定义字体样式。

format对应字体格式 以及 常见兼容性写法：

```css
@font-face {
 font-family: 'defineName';
 src: url('../fonts/custom-font.eot');
 src: url('../fonts/custom-font.eot?#iefix') format('embedded-opentype'),
      url('../fonts/custom-font.woff') format('woff'),
      url('../fonts/custom-font.ttf') format('truetype'),
      url('../fonts/custom-font.svg#defineName') format('svg');
 font-weight: normal;
 font-style: normal;
}
```

定义好自己的 font-face 后，就有了新的 IconFont，给要使用这个 IconFont 的对象赋予对应的 font-family 即可。

```css
.example {
  font-family: 'defineName';
  content: '/e103';
}
```

这个例子就会将 example 选中的元素渲染为 `/e103` 对应的 icon。

##### 使用方法

在阿里素材库网站iconfont下载素材

![clipboard.png](https://segmentfault.com/img/bVbguuA?w=587&h=292)

三种使用方式：

1、Unicode 引用

特点是：

- 支持按字体的方式去动态调整图标大小，颜色等等。
- 默认情况下不支持多色，直接添加多色图标会自动去色。

Unicode 使用步骤如下：

第一步：拷贝项目下面生成的 `@font-face`

```css
@font-face {
  font-family: 'iconfont';
  src: url('iconfont.ttf?t=1659679164412') format('truetype');
}
```

第二步：定义使用 iconfont 的样式

```css
.iconfont {
  font-family: "iconfont" !important;
  font-size: 16px;
  font-style: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
```

第三步：挑选相应图标并获取字体编码，应用于页面

```html
<span class="iconfont">&#x33;</span>
```

2、font-class 引用

**font-class 是 Unicode 使用方式的一种变种**，主要是解决 Unicode 书写不直观，语意不明确的问题。

与 Unicode 使用方式相比，具有如下特点：

- 相比于 Unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。
- 因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。

使用步骤如下：

第一步：引入项目下面生成的 fontclass 代码：

```html
<link rel="stylesheet" href="./iconfont.css">
```

第二步：挑选相应图标并获取类名，应用于页面：

```html
<span class="iconfont icon-xxx"></span>
```

**Unicode方式和FontClass方式是极其相似的，只不过他们一个用的是图标的字体编码，一个用的是图标的unicode引用而已**

3、Symbol 引用

这种用法其实是做了一个 SVG 的集合，与另外两种相比具有如下特点：

- **支持多色图标了**，不再受单色限制。
- 通过一些技巧，支持像字体那样，通过 `font-size`, `color` 来调整样式。
- 兼容性较差，支持 IE9+，及现代浏览器。
- 浏览器渲染 SVG 的性能一般，还不如 png。

使用步骤如下：

第一步：引入项目下面生成的 symbol 代码：

```html
<script src="./iconfont.js"></script>
```

第二步：加入通用 CSS 代码（引入一次就行）：

```html
<style>
.icon {
  width: 1em;
  height: 1em;
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}
</style>
```

第三步：挑选相应图标并获取类名，应用于页面：

```html
<svg class="icon" aria-hidden="true">
  <use xlink:href="#icon-xxx"></use>
</svg>
```

### 优化SVG图标

一般项目中SVG使用方式都是在iconfont生成JS然后引入（接上面iconfont的Symbel引入）。这种做法

- 不直观，每次都得去iconfont复制名称使用
- 每次增删改图标需要重新替换整个JS
- 不能**按需加载**，没使用到的也会一起打包，特别是UI换图标时一般不会将旧图标删除....
- 添加自定义SVG不友善，必须上传iconfont添加到一起再下载

##### 更优的SVG玩法

- 新增/修改图标
  - 在iconfont下载UI上传或者其他地方找的任意SVG图标放入icons/svg/下
  - 页面中使用全局svg组件，传入复制下SVG的文件名即可
- 删除
  - 只需要去掉使用的地方，然后删除对应图标即可

要实现上述效果，只需要

- 引入**svg-sprite-loader**

```lua
// install
npm i svg-sprite-loader -D
// vue.config.js
chainWebpack: (config) => {
    // SVG处理
    config.module
      .rule('svg')
      .exclude.add(resolve('src/icons/svg'))
      .end()
    config.module
      .rule('icons')
      .test(/\.svg$/)
      .include.add(resolve('src/icons/svg'))
      .end()
      .use('svg-sprite-loader')
      .loader('svg-sprite-loader')
      .options({
        symbolId: 'icon-[name]'
      })
      .end()
    
}
```

- 创建src/icons/svg并将图标放进去，并通过webpack的require.context自动导入

```javascript
// src/icons/index.js
const req = require.context('./svg', false, /\.svg$/)
const requireAll = requireContext => requireContext.keys().map(requireContext)
requireAll(req)

// main.js
import '@/icons'
```

- 创建全局组件ca-svg

```javascript
// src/icons/index.js
import Vue from 'vue'
import CaSVG from '@/components/ca-svg'
Vue.component('ca-svg', CaSVG)

// src/components/ca-svg.vue
<template>
  <svg :class="svgClass" aria-hidden="true" v-on="$listeners" :style="svgStyle">
    <use :xlink:href="iconName" />
  </svg>
</template>
...
// name属性为必须字段，其他size或color可以自由定制
```

### 使用 base64 格式

原理：将图片转换为 base64 编码字符串 inline 到页面或 css 中。

**优点**

- 提升性能: 网页上的每一个图片，都是需要消耗一个 http 请求下载而来的, 图片的下载始终都要向服务器发出请求，要是图片的下载不用向服务器发出请求，**base64 可以随着 HTML 的下载同时下载到本地.减少 https 请求**。
- 加密: 让用户一眼看不出图片内容 , 只能看到编码。
- 方便引用: 在多个文件同时使用某些图片时, 可以把图片转为 base64 格式的文件, 把样式放在全局中, 比如 common.css, 以后在用的时候就可以直接加类名, 二不需要多层找文件路径, 会提升效率

**缺点**
1、若转化的图片太大，导致数据太大，加载过慢，所以一般像Vue在limit通常默认设置的是10000B。
2、使用base64的资源**将不会拥有缓存**，即如果些张图片被用来做为有频率切换动画（例如自定义模拟喇叭播放的动画）这样就会由于图片没有缓存而反复请求导致其他的资源请求排队，pending时间从几秒到一分钟不等的问题。

但需要注意的是：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为该图片经过 base64 编码后的字符串非常大，会明显增大 HTML 页面的大小，从而影响加载速度。

base64 化最常见的就是在 url-loader 中使用。

```javascript
module.exports = {
...
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10240,
          name: utils.assetsPath('img/[name].[hash:7].[ext]'),
        }
      },
    ],
  },
}
```

这样就能将项目中小于 10kb 的图片转化为 base64 应用到页面中

### 图片懒加载

懒加载是一种网页性能优化的方式，它能极大的提升用户体验。图片一直是影响网页性能的主要元凶，现在一张图片超过几兆已经是很经常的事了。如果每次进入页面就请求所有的图片资源，那么可能等图片加载出来用户也早就走了。所以进入页面的时候，只请求可视区域的图片资源。

总结出来就是：

- 减少资源的加载，页面启动只加载首屏的图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。
- 防止并发加载的资源过多而阻塞 js 的加载，影响整个网站的启动，影响用户体验
- 浪费用户的流量，有些用户并不想全部看完，全部加载会耗费大量流量。

**原理**

图片懒加载的原理就是暂时不设置图片的 src 属性，而是将图片的 url 隐藏起来，比如先写在 data-src 里面，等当前图片是否到了可视区域再将图片真实的 url 放进 src 属性里面，从而实现图片的延迟加载。

```js
function lazyload() {
  let viewHeight = document.body.clientHeight //获取可视区高度
  let imgs = document.querySelectorAll('img[data-src]')
  imgs.forEach((item, index) => {
    if (item.dataset.src === '') return

    // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置
    let rect = item.getBoundingClientRect()
    if (rect.bottom >= 0 && rect.top < viewHeight) {
      item.src = item.dataset.src
      item.removeAttribute('data-src')
    }
  })
}

// 可以使用节流优化一下
window.addEventListener('scroll', lazyload)
```

通过上面例子的实现，我们要实现懒加载都需要去监听 scroll 事件，尽管我们可以通过函数节流的方式来阻止高频率的执行函数,但是我们还是需要去计算 scrollTop,offsetHeight 等属性，

### 使用CDN 图片

### 使用CSS代替图片

比如实现修饰效果，如半透明、边框、圆角、阴影、渐变等，在当前主流浏览器中都可以用 CSS 达成，这样能减少图片的请求，达到优化的目的。

**缺点**

- 受限于 css 的浏览器的兼容性
- 对于较复杂的图案就无能为力了，写也麻烦，开发成本大



## 内容分发网络CDN

### 何为CDN ？

CDN（**Content Delivery Network**）， 又称**内容分发网络**。
 它是建立并覆盖在承载网之上，由分布在不同区域的**边缘节点服务器群组成**的**分布式网络**。

### CDN什么作用 ？

粗略地来讲，CDN是用来**优化网络资源请求的时间**的。
 它将储存在目标服务器的资源缓存在了离终端较近的节点服务器中，等下次再获取时，就直接从节点服务器上获取。 这样就大大降低了请求获取资源的时间。

**那如何将请求分配到就近的节点服务器呢？**

CDN会通过**负载均衡技术**，将用户的请求定向到最合适的缓存服务器上去获取内容。
 比如说，北京的用户，我们让他访问北京的节点，深圳的用户，我们让他访问深圳的节点。通过就近访问，加速用户对网站的访问，进而解决Internet网络拥堵状况，提高用户访问网络的响应速度。

### 为什么要使用CDN ？

如果一个网站（作为盈利渠道或是品牌窗口）需要要吸引大流量， 以下几点因素是制胜的关键：

- 内容有吸引力
- 访问速度快
- 支持频繁的用户互动
- 可以在各处浏览无障碍

满足这些条件的前提就是：**网站访问快**

那么`CDN`就是一个**加速网站访问**的优秀解决方案

除此之外，CDN还有一些作用：

**1. 为了实现跨运营商、跨地域的全网覆盖**

互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。阿里云在国内有500+节点，海外300+节点，覆盖主流国家和地区不是问题，可以确保CDN服务的稳定和快速。

**2. 为了保障你的网站安全**

CDN的负载均衡和分布式存储技术，可以加强网站的**可靠性**，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。

**3. 为了异地备援**

当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。

**4. 为了节约成本投入**

使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。

**5. 为了让你更专注业务本身**

CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。

### ⚝CDN访问过程/工作原理

![](pics/cdn1.png)

1、用户访问图片内容，先经过 `本地DNS` 解析，如果 LDNS 命中，直接返回给用户。

2、`LDNS` MISS，转发 `授权DNS` 查询

3、当授权DNS解析域名时，返回**域名CNAME 指向的DNS调度系统**对应IP地址。

4、域名解析请求发送至`DNS调度系统`，DNS调度系统为请求分配最佳节点IP地址。

5、返回解析`IP地址`

6、用户向`缓存服务器`发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。

### CDN组成

CDN网络主要由中心节点、边缘节点两部分构成。

#### **中心节点**

中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责**整个CDN网络的分发及管理**。

#### **边缘节点**

CDN边缘节点主要指异地分发节点，由**负载均衡设备**、高速缓存服务器两部分组成。

负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率；同时还负责收集节点与周围环境的信息，保持与全局负载均衡DNS的通信，实现整个系统的负载均衡。

高速缓存服务器（Cache）负责存储客户网站的大量信息，就像一个靠近用户的网站服务器一样响应本地用户的访问请求。通过全局负载均衡DNS的控制，用户的请求被透明地指向离他最近的节点，节点中Cache服务器就像网站的原始服务器一样，响应终端用户的请求。因其距离用户更近，故其响应时间才更快。

![](pics/cdn2.png)

### CDN 调度策略

##### DNS 调度

基于请求端 local DNS 的出口 IP 归属地以及运营商的 DNS 调度。

DNS 调度的问题：

- DNS 缓存时间在 TTL 过期前是不会刷新的， 这样会导致节点异常的时候自动调度延时很大，会直接影响线上业务访问。
- 大量的 local DNS 不支持 EDNS 协议，拿不到客户的真实IP，CDN 绝大多数时候只能通过local DNS IP来做决策，经常会出现跨区域调度的情况。

##### HTTP DNS 调度

客户端请求固定的 HTTP DNS 地址，根据返回获取解析结果。可以提高解析的准确性(不像DNS调度，只能通过local DNS IP来做决策)，能很好的避免劫持等问题。

当然这种模式也有一些问题，例如客户端每次加载URL都可能产生一次HTTP DNS查询，这就对性能和网络接入要求很高。

##### 302调度

基于客户端 IP 和 302 调度集群进行实时的流量调度。

我们来看一个例子：

1. 访问 URL 链接后，此时请求到了调度群集上，我们能拿到的客户端信息有 客户端的出口IP（绝大多情况下是相同的），接下来算法和基于 DNS 的调度可以是一样的，只是判断依据由 local DNS 出口 ip 变成了客户端的出口IP。
2. 浏览器收到302回应，跟随 Location 中的 URL，继续发起 http 请求，这次请求的目标 IP 是CDN 边缘节点，CDN节点会响应实际的文件内容。

302 调度的优势：

- 实时调度，因为没有 local DNS 缓存的，适合 CDN 的削峰处理，对于成本控制意义重大；
- 准确性高，直接获取客户端出口 IP 进行调度。

302 调度的劣势：

- 每次都要跳转，对于延时敏感的业务不友好。一般只适用于大文件。

##### AnyCast BGP路由调度

基于 BGP AnyCast 路由策略，只提供极少的对外 IP，路由策略可以很快的调整。

目前 AWS CloudFront、CloudFlare 都使用了这种方式，在路由层面进行调度。

这种方式可以很好地抵御 DDOS 攻击，降低网络拥塞。

当然这种方式的成本和方案设计都比较复杂，所以国内的 CDN 目前还都是用 UniCast 的方式。



### CDN适用场景

CDN应用广泛，支持多种行业、多种场景内容加速，例如：

- 图片小文件
- 大文件下载
- 视音频点播
- 直播流媒体
- 全站加速
- 安全加速。

### ⚝CDN在项目中的使用

Vue项目打包的时候，默认会`把所有代码合并`生产新文件,其中包括各种库导致打包出来很大。如果使用cdn的话,会更利于程序的加载速度。

在Vue项目中，**引入到工程中的所有js、css文件，编译时都会被打包进vendor.js**，浏览器在加载该文件之后才能开始显示首屏。若是引入的库众多，那么vendor.js文件**体积将会相当的大**，影响首开的体验。

#### **解决方法**

将引用的外部js、css文件剥离开来，**不编译到vendor.js中**，而是**用资源的形式引用**，这样浏览器可以使用多个线程异步将vendor.js、外部的js等加载下来，达到加速首开的目的。

外部的库文件，可以使用`CDN资源`，或者别的服务器资源等。

#### **使用CDN主要解决两个问题**

1. 打包时间太长、打包后代码体积太大，请求慢
2. 服务器网络不稳带宽不高，使用cdn可以回避服务器带宽问题

#### 具体步骤

将依赖的`vue`、`vue-router`、`vuex`、`element-ui`和`axios`这五个库，全部改为通过`CDN`链接获取。

#### 资源引入

##### 1. 在项目根目录index.html使用cdn节点导入

```html
<body>
    <div id="app"></div>
    <!-- built files will be auto injected -->
    <!--开发环境-->
    <script src="https://cdn.bootcss.com/vue/2.6.11/vue.js"></script>
    <!--生产环境-->
    <!--<script src="https://cdn.bootcss.com/vue/2.6.11/vue.min.js"></script>-->
    <!-- 引入组件库 -->
    <script src="https://cdn.bootcss.com/vue-router/3.2.0/vue-router.min.js"></script>
    <script src="https://cdn.bootcss.com/axios/0.23.0/axios.min.js"></script>
    <script src="https://cdn.bootcss.com/element-ui/2.15.6/index.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
</body>
```

##### 2. 在vue.config.js中加入externals外部扩展

```js
configureWebpack: {
    externals: {
        "vue": "Vue",
        "vue-router": "VueRouter",
        "axios": "axios",
        "moment": "moment",
        "element-ui": "ELEMENT",
    }
},
```

这里解释一下`externals` 配置选项的作用：

> 我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals。

踩坑配置注意点：element-ui要大写为ELEMENT

##### 3. 卸载依赖的`npm`包，`npm uninstall axios element-ui vue vue-router vuex`

4.去掉原有的引用

如果不删除原先的`import`，项目还是会从`node_modules`中引入资源。
 也就是说不删的话，`npm run build`时候仍会将引用的资源一起打包，生成文件会大不少。所以我认为还是删了好

所有 的`js`和`css`等静态资源都是请求的我们**自己的`nginx`服务器**，而现在大部分的静态资源都请求的是第**三方的`CDN`资源**， 这不仅可以带来速度上的提升，在高并发的时候，这无疑大大降低的自己服务器的带宽压力，想象一下原来首屏900多KB的文件 现在仅剩20KB是请求自己服务器的！

## DNS优化

#### 使用HttpDns

**Local DNS有什么缺陷**

- Local DNS劫持

> 域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的。

- DNS解析过慢

DNS解析分为递归查询和迭代查询两种。

> 递归查询：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步的查询。

> 迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：你下一步应当向哪一个域名服务器进行查询。然后让本地域名服务器进行后续的查询，而不是替本地域名服务器进行后续的查询。

由于递归模式会导致DNS服务器流量很大，所以现在大多数采用迭代模式。

由于端上网络环境的复杂性已经DNS解析的流程也较为复杂，有些场景下DNS解析时间高达几百毫秒，对于一次网络请求来说，是相当缓慢的。

**什么是HttpDns**

> HTTPDNS 是面向移动开发者推出的一款域名解析产品，具有域名防劫持、精准调度等特性。

目前来说，腾讯和阿里都有自己的HTTPDNS解决方案。HTTPDNS有以下特性：

1. 安全，由于httpdns使用http或者https协议通过ip直连的方式进行解析，绕过了运营商的Local DNS，避免了域名劫持
2. 快速，通过预解析机制，将热点域名提前解析，网络连接时直接缓存获取



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f510e63c58ec12~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### DNS预加载

```
<link rel="dns-prefetch" href="//www.baidu.com">

<link rel="preload" href="style.css" **as**="style">
```

#### DNS缓存优化

设置合理的缓存时间

#### 页面中资源的域名的合理分配。

减少一个新域名，就能减少一次DNS Lookup

#### 稳定可靠的DNS服务器等。



## HTTP2

HTTP2较于HTTP1 速度更快、延迟更低，功能更多。 目前来看[兼容性](https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2F%3Fsearch%3Dhttp2)方面也算过得去，在国内有超过50%的覆盖率。

通常浏览器在传输时**并发请求数**是有限制的，超过限制的请求需要排队，以往我们通过**域名分片、资源合并**来避开这一限制，而使用HTTP2协议后，其可以在一个TCP连接分帧处理多个请求（**多路复用**），不受此限制。（其余的**头部压缩**等等也带来了一定性能提升）

如果**网站支持HTTPS，请一并开启HTTP2**，**因为Chrome/Safari/Firefox/Opera等浏览器只支持https的http/2**，成本低收益高，对于请求多的页面提升很大，尤其是在网速不佳时

**Nginx开启HTTP2（>V1.95）**

#### 升级Https

升级到`Http2.0`就必须先升级到`Https`

升级`Https`，我们需要先在下载或者购买SSL证书中，下载cert证书，然后放到[nginx](https://so.csdn.net/so/search?q=nginx&spm=1001.2101.3001.7020)服务器上

1、查看nginx是否支持ssl

2、配置ssl模块

3、重新编译一下nginx

#### 升级HTTP2

- 调整Nginx配置

```cpp
// nginx.conf
listen 443 http2;
```

- 重启Nginx

```vbnet
nginx -s stop && nginx
```

- 验证效果

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcfc9f507bfe47f2beae758cabdb8d4f~tplv-k3u1fbpfcp-watermark.awebp)

HTTP2开启后

> 多路复用避开了资源并发限制，但资源太多的情况，也会造成浏览器性能损失（Chrome进程间通信与资源数量相关）

#### 是什么决定http使用版本

1. DNS 查找。找到stackoverflow的ip地址。
2. TCP握手
3. TLS握手。
4. HTTP 请求/响应（应用程序协议）。
5. ……

TLS握手时，服务端响应中设置了这次http的版本

- 选择的密码套件。
- 选择 TLS 版本。
- 一个随机生成的数字
- 并且，在[TLS 应用层协议协商 (ALPN)](https://www.rfc-editor.org/rfc/rfc7301)中选择的应用协议，例如`HTTP/2`

## 缓存策略

该策略主要围绕`浏览器缓存`做相关处理，同时也使接入成本最低的`性能优化策略`。其显著减少网络传输所带来的损耗，提升网页访问速度，是一种很值得使用的`性能优化策略`。

通过下图可知，为了让`浏览器缓存`发挥最大作用，该策略尽量遵循以下五点就能发挥`浏览器缓存`最大作用。

- **考虑拒绝一切缓存策略**：`Cache-Control:no-store`
- **考虑资源是否每次向服务器请求**：`Cache-Control:no-cache`
- **考虑资源是否被代理服务器缓存**：`Cache-Control:public/private`
- **考虑资源过期时间**：`Expires:t/Cache-Control:max-age=t,s-maxage=t`
- **考虑协商缓存**：`Last-Modified/Etag`

![缓存判断机制](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f245496e62f4d1f96f48363512267cc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

有两种较常用的应用场景值得使用`缓存策略`一试，当然更多应用场景都可根据项目需求制定。

- **频繁变动资源**：设置`Cache-Control:no-cache`，使浏览器每次都发送请求到服务器，配合`Last-Modified/ETag`验证资源是否有效
- **不常变化资源**：设置`Cache-Control:max-age=31536000`，对文件名**哈希处理**，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件

### 实际场景

前端SPA部署来说，打包过后的文件为 index.html、css、js、img 文件等，

（1）index.html 应该**不缓存**，**或者**是**设置 no-cache 的强缓存**（即资源被缓存，但立即失效，下次请求会验证资源是否过期）+ **协商缓存**，保证 index.html 每次都从服务器获取最新的；（协商缓存需要配合强缓存使用）

（2）js、css、img 等文件使用**强缓存**，并且打包后生成对应的 **hash值**，所以这些文件可以设置一个比较长的缓存时间，比如1年；

在更新版本之后，为了让用户第一时间使用最新的资源文件，可以在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。**通常的方法可以用webpack打包时候加上hash值**

```js
entry:{
    main: path.join(__dirname,'./main.js'),
    vendor: ['react', 'antd']
},
output:{
    path:path.join(__dirname,'./dist'),
    publicPath: '/dist/',
    filname: 'bundle.[chunkhash].js'
}
```

webpack给我们提供了三种哈希值计算方式，分别是hash、chunkhash和contenthash。那么这三者有什么区别呢？

- hash：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。
- chunkhash：根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。
- contenthash：由文件内容产生的hash值，内容不同产生的contenthash值也不一样。

### 用户行为对浏览器缓存的影响

　　所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：

1、打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。

2、普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。

3、强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control: no-cache`(为了兼容，还带了 `Pragma: no-cache`)，服务器直接返回 200 和最新内容

## GZIP压缩传输

在 `http／1.0` 协议中关于服务端发送的数据可以配置一个 `Content-Encoding` 字段，这个字段用于说明数据的压缩方法

```csp
Content-Encoding: gzip
Content-Encoding: compress
Content-Encoding: deflate
```

客户端在接受到返回的数据后去检查对应字段的信息，然后根据对应的格式去做相应的解码。客户端在请求时，可以用 `Accept-Encoding` 字段说明自己接受哪些压缩方法。

```ada
Accept-Encoding: gzip, deflate
```

**当响应头的` Content-Encoding`指定了gzip时，浏览器则会进行对应解压**

使用`Gzip`两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。

#### 谁去压缩

 `nginx` 开启 `gZip` 配置能够进行gzip压缩，用 `webpack` 作为打包工具，其中可以配置插件 如[compression-webpack-plugin](https://link.segmentfault.com/?enc=uQp%2BoluXV1g82ApJcE%2FJkA%3D%3D.fGNx%2BF2bozbpvKgnV186eMFYs1LmjtjHQ7oRZsBM%2BogMSpng2D%2BrpfYYcpwYxfPCROKj1JSnJqe%2BuEpjPoHpYQ%3D%3D) 也能进行 `gZip` 等压缩并生成对应的压缩文件，而我们应用在构架时候有可能也会在服务区和前端文件中放置一层 `node` 应用来进行接口鉴权和文件转发。`nodejs`中我们熟悉的`express` 框架中也有一个[compression](https://link.segmentfault.com/?enc=V6qvXJubF4M45TameBSiIw%3D%3D.kpIKBMZVNroRRs94M4h04f%2F4tJ2mVl9HOjA63hG%2B8e2iuSyR%2F%2FdoetIOomP2tuho) 中间件，可以开启`gZip`,一时间看的人眼花缭乱，到底应该用谁怎么用呢？

其实 `nginx` 压缩和 webpack去压缩都是一样的，当我们点击网页发送一个请求时候，我们的服务端会找到对应的文件，然后对文件进行压缩返回压缩后的内容【当然可以利用缓存减少压缩次数】，并配置好我们上面提到的 `Content-Encoding` 信息。对于一些应用在构架时候并没有上游代理层，比如服务端就一层 `node` 就可以直接用自己本身的压缩插件对文件进行压缩，如果上游配有有 `nginx` 转发处理层，最好交给 `nginx` 来处理这些，因为它们有专门为此构建的内容，可以更好的利用缓存并减小开销（很多使用c语言编写的）。

既然服务端都可以做了为什么 `webpack` 在打包前端应用时候还有这样一个压缩插件呢，我们可以在上面 `nginx` 配置中看到 **gzip_comp_level 2 这个配置项**，上面也有注释写道 `1-10` 数字越大压缩效果越好，但是**会耗费更多的CPU和时间**，我们压缩文件除了减少文件体积大小外，也是为了减少传输时间，如果我们把压缩等级配置的很高，**每次请求服务端都要压缩很久才回返回信息回来，不仅服务器开销会增大很多，请求方也会等的不耐烦**。但是现在的 `spa` 应用既然文件都是打包生成的，那如果我们在打包时候就直接生成高压缩等级的文件，作为静态资源放在服务器上，**可以分担服务器压力**

#### webpack配置

`webpack` 的 `compression-webpack-plugin` 就是做这个事情的，配置起来也很简单只需要在装置中加入对应插件,简单配置如下

```javascript
const CompressionWebpackPlugin = require('compression-webpack-plugin');

webpackConfig.plugins.push(
    new CompressionWebpackPlugin({
      asset: '[path].gz[query]',
      algorithm: 'gzip',
      test: new RegExp('\\.(js|css)$'),
      threshold: 10240,
      minRatio: 0.8
    })
)
```

`webpack` 打包完成后生成打包文件外还会额外生成 `.gz` 后缀的压缩文件

![图片描述](https://segmentfault.com/img/bV1R5g?w=1492&h=168)

那么这个插件的压缩等级是多少呢，我们可以在[源码](https://link.segmentfault.com/?enc=vJ4%2FAfQ6A%2BmC7bwKEqFlfA%3D%3D.uHQ%2FYyWhZl%2BBduh0%2B6uODGA%2FOCahfEiBzf5ucufny7IJX%2B4NuKfULy2Up4npNueGLO09jv%2BlF%2BNYGWW7%2B7519Rur%2FjmoK6Zbc24HPi0y1czDPpoPPy%2FB3Y%2BCTopP7Mwv)中看到默认的 `level` 是 **9**

```javascript
...
const zlib = require('zlib');
this.options.algorithm = zlib[this.options.algorithm];
...
this.options.compressionOptions = {
    level: options.level || 9,
    flush: options.flush
    ...
}
```

可以看到压缩使用的是 `zlib` 库，而 `zlib` 分级来说，默认是 6 ，最高的级别就是`9 Best compression (also zlib.Z_BEST_COMPRESSION)`,因为我们只有在上线项目时候才回去打包构建一次，所以我们在构建时候使用最高级的压缩方式压缩多耗费一些时间对我们来说根本没任何损耗，而我们在服务器上也不用再去压缩文件，只需要找到相应已经压缩过的文件直接返回就可以了。

## 服务端渲染SSR

#### **SSR优点**

1、加快首屏时间

传统 SPA 需完整的 JS 下载完成才可执行，而SSR 服务器渲染标记在服务端渲染 html 后即可显示，用户会更快的看到首屏渲染页面。如果首屏渲染时间转化率对应用程序至关重要，那可以使用 SSR 来优化。

2、优化SEO抓取

**需更好的支持 SEO** 优势在于**同步**。搜索引擎爬虫是不会等待异步请求数据结束后再抓取信息的，如果 SEO 对应用程序至关重要，但你的页面又是异步请求数据，那 SSR 可以帮助你很好的解决这个问题。

以下三种场景 SSR 使用需要慎重

- **同构资源的处理** 劣势在于程序需要具有通用性。结合 Vue 的钩子来说，能在 SSR 中调用的生命周期只有 **beforeCreate** 和 **created**，这就导致在使用三方 API 时必须保证运行不报错。在三方库的引用时需要特殊处理使其支持服务端和客户端都可运行。
- **部署构建配置资源的支持** 劣势在于运行环境单一。程序需处于 **node.js server** 运行环境。
- **服务器更多的缓存准备** 劣势在于高流量场景需采用缓存策略。应用代码需在双端运行解析，cpu 性能消耗更大，负载均衡和多场景缓存处理比 SPA 做更多准备。

#### SSR的缺点

1. 不利于前后端分离,开发效率低,使用服务端渲染,不利于项目高效开发.另外,如果是服务器端渲染,则前端就简单开发一个静态html页面,然后后端修改成模板,
2. 占用服务器端资源,即服务器端完成html模板的解析,如果请求过多,会对服务器造成一定的压力,如果是前端渲染,就把这些解析的压力分摊给了前端.

#### CSR和SSR的区别

因此，CSR和SSR最大的区别在于前者的页面渲染是JS负责进行的，而后者是服务器端直接返回HTML让浏览器直接渲染。

为什么要使用服务端渲染呢？



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/2/16bb28547b52c0bd~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

传统CSR的弊端：



1. 由于页面显示过程要进行JS文件拉取和React代码执行，首屏加载时间会比较慢。
2. 对于SEO(Search Engine Optimazition,即搜索引擎优化)，完全无能为力，因为搜索引擎爬虫只认识html结构的内容，而不能识别JS代码内容。

SSR的出现，就是为了解决这些传统CSR的弊端。

#### ⚝核心原理

整体来说 `react` 服务端渲染原理不复杂，其中最核心的内容就是同构。

`node server` **接收客户端请求**，得到当前的`req url path`,然后**在已有的路由表内查找到对应的组件**，拿到需要请求的数据，将**数据**作为 `props` 、`context`或者`store` 形式**传入组件**，然后基于 `react` 内置的服务端渲染api `renderToString() or renderToNodeStream()` 把**组件渲染为 `html字符串`**或者 `stream 流`, 在把最终的 `html` 进行输出前需要**将数据注入到浏览器端**(注水)，server 输出(response)后浏览器端可以得到数据(脱水)，**浏览器开始进行渲染和节点对比**，然后执行组件的`componentDidMount` 完成组件**内事件绑定和一些交互**，浏览器重用了服务端输出的 `html 节点`，整个流程结束。

这里放一个架构图

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/17/16d3ea2efbfc1270~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



## Preconnect、Prefetch、Preload

例如：`<link rel="preconnect" href="https://code.jquery.com" as="script">`

1. preconnect ( 对比 dns-prefetch )

   **提前 DNS查询，TLS协商，tcp握手**

   1. 对当前域名的资源无效（因为已经有缓存了
   2. 一般对cdn或其他域的资源 有效

   场景：页脚有个cdn资源<script>，则可以在页眉可以放一个preconnect资源提示

   ```html
   <head>
     <meta charset="utf-8">
     <title>preconnect example</title>
     
     <link rel="preconnect" href="https://code.jquery.com/jquery-3.6.0.min.js" as="script">
   </head>
   
   <body>
     <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
   </body>
   ```

   **对比：dns-prefetch，  dns-prefetch只有DNS查询，多了2次RTT**（Round-trip delay 往返延迟）

   `<link rel="dns-prefetch" href="https://fonts.googleapis.com/"> `

2. preload 预加载（用法几乎同上）

   作用：**提前加载资源**：提前 DNS查询，TLS协商，tcp握手，和**资源下载**

   支持的格式多：image，style，script，font，audio，video 等

   场景：希望把 资源 放页脚（不阻塞dom解析），然后又想让资源提前下载，就可以用 preload + as="[type]"

   建议不要滥用：因为他的优先级会提很高，只在会影响白屏时间的重点资源上使用（预加载）(不要所有的资源都加preload，优先级没那么高的资源，就不要跟优先级高的抢了)

   ```html
   <head>
     <meta charset="utf-8">
   
     <link rel="preload" href="style.css" as="style">
     <link rel="preload" href="main.js" as="script">
   
     <link rel="stylesheet" href="style.css">
   </head>
   
   <body>
     <h1>bouncing balls</h1>
     <canvas></canvas>
   
     <script src="main.js"></script>
   </body>
   
   -----------------
   
   <head>
     <meta charset="utf-8">
     <title>Video preload example</title>
     <link rel="preload" href="sintel-short.mp4" as="video" type="video/mp4">
   </head>
   <body>
     <video controls>
       <source src="sintel-short.mp4" type="video/mp4">
       <source src="sintel-short.webm" type="video/webm">
       <p>Your browser doesn't support HTML5 video. Here is a <a href="sintel-short.mp4">link to the video</a> instead.</p>
     </video>
   </body>
   ```

3. prefetch 预请求（用法几乎同上）

   作用：提前下载**未来某个资源** （**当前页面资源加载完了后，才会去预取**）

   - 预取“将来”的资源（比如下一个页面，用户也有概率不到下一个页面），优先级比preload低（因为是下一个页面，preload是作用于当前页面）
     - 可以预下载资源到浏览器缓存，等到真正执行的时候，就直接拿缓存

   场景：下一个页面有个cdn资源<script>，则可以在当前页加 个link标签 prefetch资源提示符

   `<link rel="prefetch" href="https://code.jquery.com/jquery-3.6.0.min.js" as="script"></link>`

   注意：

   - 在 Chrome 中，如果用户导航离开一个页面，而对其他页面的预取请求仍在进行中，这些请求将不会被终止。
   - 此外，无论资源的可缓存性如何，`prefetch` 请求在未指定的网络堆栈缓存中至少保存 5 分钟。

## 预渲染Prerender

无需使用`web` 服务器实时动态编译 `HTML`，而是使用**预渲染方式**，在构建时 (`build time`) 简单地生成针对**特定路由的静态` HTML` 文件。**

场景：

常见的`Vue`单页应用构建之后的`index.html`只是一个包含根节点的空白页面，当所有需要的`js`加载完毕之后，才会开始解析并创建`vnode`,然后再渲染出真实的`DOM`。当这些`js`文件过大而网速又很慢或者出现意料之外的报错时，就会出现所谓的白屏，相信做`Vue`开发的小伙伴们一定都遇到过这种情况。而且单页应用还有一个很大的弊端就是对`SEO`很不友好。

好处：

- 更好的 `SEO`，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。
- 更快的内容到达时间 (`time-to-content`)，特别是对于缓慢的网络情况或运行缓慢的设备。

使用：

首先需要将vue的router模式设置成history模式

1. 安装`prerender-spa-plugin`依赖

```sql
yarn add prerender-spa-plugin --dev
```

2. 创建`vue.config.js`

```js
// vue.config.js
const path = require('path')
const PrerenderSPAPlugin = require('prerender-spa-plugin')
const Renderer = PrerenderSPAPlugin.PuppeteerRenderer

function resolve (dir) {
  return path.join(__dirname, dir)
}

module.exports = {
  publicPath: './',
  configureWebpack: () => {
    if (process.env.NODE_ENV === 'production') {
      return {
        plugins: [
          new PrerenderSPAPlugin({
            staticDir: resolve('dist'),
            routes: ['/', '/about'], // 你需要预渲染的路由
            renderer: new Renderer({
              inject: {
                _m: 'prerender'
              },
              // 渲染时显示浏览器窗口，调试时有用
              headless: true,
              // 等待触发目标时间后，开始预渲染
              renderAfterDocumentEvent: 'render-event'
            })
          })
        ]
      }
    }
  }
}
```

3. 在生命周期里调用自定义事件

```js
// main.js
import Vue from 'vue'
import App from './App.vue'
import router from './router'

Vue.config.productionTip = false

new Vue({
  router,
  render: h => h(App),
  mounted () {
    // 触发renderAfterDocumentEvent
    document.dispatchEvent(new Event('render-event'))
  }
}).$mount('#app')
```

没有使用预渲染得到根目录`html文件`：

![Xnip2019-08-23_15-26-53.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e845d895c96a44f0a62fb62e52797576~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

使用预渲染得到根目录`html文件`：

![Xnip2019-08-23_15-27-44.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4879548f0e6f4fc9a8308e7e5a646d60~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

可以看到使用预渲染时初始化的`HTML`文件已经有了`DOM`结构，这样爬虫就可以来抓取到`DOM`结构，`SEO`优化更好。

#### 坑

如果使用了路由懒加载，会报错。

因为`prerender-spa-plugin`渲染静态页面时，也会将类似于`<script src="/static/js/0.9231fc498af773fb2628.js" type="text/javascript" async charset="utf-8"></script>`这样的异步`script`标签注入到生成的`html`的`head`标签内。这会导致它先于`app.js`,`vendor.js`,`manifest.js`（位于`body`底部）执行。（`async`只是不会阻塞后面的`DOM`解析，这并不意味这它最后执行）。而且当这些`js`加载完毕后，又会在`head`标签重复创建这个异步的`script`标签。虽然这个报错不会对程序造成影响，但是最好的方式，还是不要把这些异步组件直接渲染到最终的`html`中。好在`prerender-spa-plugin`提供了`postProcess`选项，可以在真正生成`html`文件之前做一次处理，这里我使用一个简单的正则表达式，**将这些异步的`script`标签剔除**。

#### 原理

在webpack打包结束并生成文件后（after-emit hook），会启动一个server模拟网站的运行，用puppeteer（google官方的headless 无头浏览器）访问指定的页面route，然后将 Puppeteer 中渲染的页面输出到 HTML 文件中，并建立路由对应的目录。

## CSS策略

#### 内联首屏关键CSS

将CSS直接内联到HTML文档中能使CSS更快速地下载。而使用外部CSS文件时，需要在HTML文档下载完成后才知道所要引用的CSS文件，然后才下载它们。所以说，**内联CSS能够使浏览器开始页面渲染的时间提前**，因为在HTML下载完成之后就能渲染了。

但是不能内敛较大的CSS文件，会使服务器和浏览器之间进行多次的往返，我们应当**只将渲染首屏内容所需的关键CSS内联到HTML中**。

不过内联CSS有一个缺点，**内联之后的CSS不会进行缓存**，每次都会重新下载。

#### 异步加载CSS

CSS会阻塞渲染，在CSS文件请求、下载、解析完成之前，浏览器将不会渲染任何已处理的内容。有时，这种**阻塞是必须的，因为我们并不希望在所需的CSS加载之前，浏览器就开始渲染页面**。那么将首屏关键CSS内联后，剩余的CSS内容的阻塞渲染就不是必需的了，可以使用外部CSS，并且**异步加载**。

```HTML
<link rel="preload" href="mystyles.css" as="style" onload="this.rel='stylesheet'">
```

注意，`as`是必须的。忽略`as`属性，或者错误的`as`属性会使`preload`等同于`XHR`请求，浏览器不知道加载的是什么内容，因此此类资源加载优先级会非常低。`as`的可选值可以参考上述标准文档。

#### CSS构建策略

- 避免出现超过三层的`嵌套规则`
- 避免为`ID选择器`添加多余选择器
- 避免使用`标签选择器`代替`类选择器`
- 避免使用`通配选择器`，只对目标节点声明规则
- 避免重复匹配重复定义，关注`可继承属性`



#### 封装公共样式

把长段相同样式提取出来作为公用样式使用，比如常用的清除浮动，单行超出显示省略号，多行超出省略号等等。

## DOM策略

- 缓存`DOM计算属性`
- 避免过多`DOM操作`
- 使用`DOMFragment`缓存批量化`DOM操作`
- 删除不必要的代码和注释包括空格,尽量做到最小化文件。



## 阻塞策略

**所有初始化用不到的js 文件全部走异步加载**，也就是加上`defer`或者`asnyc` ，并且一些需要走cdn的第三方插件需要放在页面底部（因为放在顶部，他的解析会阻止html 的解析，从而影响css 等文件的下载，这也是`雅虎军规`的一条）

- 脚本与`DOM/其它脚本`的依赖关系很强：对`<script>`设置`defer`
- 脚本与`DOM/其它脚本`的依赖关系不强：对`<script>`设置`async`

#### defer 和 async 属性的区别

*![](pics/async和defer对比.png)*

其中蓝色线代表JavaScript加载；红色线代表JavaScript执行；绿色线代表 HTML 解析。

1）情况1`<script src="script.js"></script>`

没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。

2）情况2`<script async src="script.js"></script>`  (**异步下载**)

async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果**已经加载好，就会开始执行**——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript **依然会阻塞 load 事件**。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。

3）情况3 `<script defer src="script.js"></script>`(**延迟执行**)

defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 **document 解析完毕**且 defer-script 也加载完成之后（这两件事情的顺序无关），才会**执行**所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。

defer 与相比普通 script，有两点区别：**载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。 在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载**



## 回流重绘策略

##### CSS

- 避免使用 table 布局。
- 尽可能在 DOM 树的最末端改变 class。
- 避免设置多层内联样式。
- 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。
- 避免使用 CSS 表达式（例如：calc()）。

##### Javascript

- **避免频繁操作样式**,最好一次性重写 style 属性,或者将样式列表定义为 class 并一次性更改 class 属性。
- **避免频繁操作 DOM**,创建一个 documentFragment,在它上面应用所有 DOM 操作,最后再把它添加到文档中。
- **也可以先为元素设置 display: none**,操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性,如果**确实需要多次使用,就用一个变量缓存**起来。
- 对具有复杂动画的元素**使用绝对定位**,使它脱离文档流,否则会引起父元素及后续元素频繁回流。



## 异步更新策略

- 在`异步任务`中修改`DOM`时把其包装成`微任务`



## 使用 Web Workers

Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。

Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。

创建一个新的 worker 很简单，指定一个脚本的 URI 来执行 worker 线程（main.js）：

```js
var myWorker = new Worker('worker.js');
// 你可以通过postMessage() 方法和onmessage事件向worker发送消息。
first.onchange = function() {
  myWorker.postMessage([first.value,second.value]);
  console.log('Message posted to worker');
}

second.onchange = function() {
  myWorker.postMessage([first.value,second.value]);
  console.log('Message posted to worker');
}
```

在 worker 中接收到消息后，我们可以写一个事件处理函数代码作为响应（worker.js）：

```js
onmessage = function(e) {
  console.log('Message received from main script');
  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);
  console.log('Posting message back to main script');
  postMessage(workerResult);
}
```

onmessage处理函数在接收到消息后马上执行，代码中消息本身作为事件的data属性进行使用。这里我们简单的对这2个数字作乘法处理并再次使用postMessage()方法，将结果回传给主线程。

回到主线程，我们再次使用onmessage以响应worker回传的消息：

```js
myWorker.onmessage = function(e) {
  result.textContent = e.data;
  console.log('Message received from worker');
}
```

在这里我们获取消息事件的data，并且将它设置为result的textContent，所以用户可以直接看到运算的结果。

不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。

## 感知性能优化

### 首屏骨架屏加载

#### 切换图片的思路实现骨架屏

 因为浏览器加载网页资源是有先后顺序的：`html、css、font这三类资源优先级最高；然后是preload资源、js脚本、xhr请求；接着是图片、语音、视频资源；最低的是prefetch资源`，因为加载资源会使页面阻塞所以我们需要更早的显示出图片减少白屏时间。

- 使用preload提高图片加载优先级
- 尽量减少图片的体积以加快加载速度
- 获取到数据后隐藏图片

### 白屏时的loading动画

首屏优化，在JS没解析执行前，让用户能看到Loading动画，减轻等待焦虑。通常会在index.html上写简单的CSS动画，直到Vue挂载后替换挂载节点的内容，但这种做法实测也会出现短暂的白屏，建议手动控制CSS动画关闭



## Vue优化

#### vue 中的函数式组件

在vue中我们知道组件的初始化是比较损耗性能的，大家可以去试一下，使用vue 直接渲染一个文字内容，和直接渲染一个app.vue 组件他的分数是略有不同的。

但是当有了函数式组件，这个问题就迎刃而解了

因为函数是组件顾名思义他就是个函数，说白了就是个`render函数`，他少了组件初始化的过程，省去了很多初始化过程的`开销`

**什么时候用函数式组件呢?**

当你的组件中没有业务逻辑只展示内容时，这时候函数式组件就派上用场了

#### 利用v-show 、KeepAlive 复用dom

我们知道v-show是通过display 控制dom的展示隐藏，他并不会删除dom 而我们在切换v-show的时候其实是减少了diff的对比，而KeepAlive 则是直接复用dom，**能在组件切换过程中将状态保留在内存中，防止重复渲染DOM**。连diff 的过程都没了，并且他们俩的合理使用还不会影响到初始化渲染。如此一来减少了js 的执行开销，但是值得注意的是，`他并不能优化你初始化的性能，而是操作中的性能`

**`keep-alive`的声明周期执行**

- 页面第一次进入，钩子的触发顺序
   `created-> mounted-> activated`，
   退出时触发 `deactivated ` 当再次进入（前进或者后退）时，只触发 `activated`
- 事件挂载的方法等，只执行一次的放在 `mounted` 中；组件每次进去执行的方法放在 `activated` 中；


#### computed 和 watch  区分使用场景

**computed：** 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；

**watch：** 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

**运用场景：**

- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
- 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

#### v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

#### 长列表性能优化

Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 **Object.freeze 方法来冻结一个对象**，一旦被冻结的对象就再也不能被修改了。

```javascript
export default {
  data: () => ({
    users: {}
  }),
  async created() {
    const users = await axios.get("/api/users");
    this.users = Object.freeze(users);
  }
};
```

#### 事件的销毁

Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：

```javascript
created() {
  addEventListener('click', this.click, false)
},
beforeDestroy() {
  removeEventListener('click', this.click, false)
}
```




### 代码层面

（1）合理使用v-if和v-show

（2）合理使用watch和computed

（3）使用v-for必须添加key, 最好为唯一id, 避免使用index, 且在同一个标签上，v-for不要和v-if同时使用

（4）定时器的销毁。可以在beforeDestroy()生命周期内执行销毁事件；也可以使用$once这个事件侦听器，在定义定时器事件的位置来清除定时器。详细见vue官网

1. 优化HTML代码和结构，缩短HTML下载时间，加快HTML解析速度。
2. 优化CSS文件和结构，缩短CSS文件下载时间和解析时间。
3. 合理优化Js代码。并合理放置JS代码，避免前面第三种情况的出现，这也是最重要的。

通常内联的 JS代码运行大概消耗几十毫秒，也就是暂停构建几毫秒到几十毫秒。

它最大的危害在于上面第三种情况提到的，即DOM树构建被阻塞的时间不是只有JS代码运行的时间，而是会加上样式资源文件下载和CSSOM 树的构建时间，这时浏览器所进行的串行解析过程，与我们在前面期望的DOM树和CSSOM树的并行解析过程相差甚远。
